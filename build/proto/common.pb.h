// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2eproto;
class Array;
struct ArrayDefaultTypeInternal;
extern ArrayDefaultTypeInternal _Array_default_instance_;
class Attribute;
struct AttributeDefaultTypeInternal;
extern AttributeDefaultTypeInternal _Attribute_default_instance_;
class DataColumn;
struct DataColumnDefaultTypeInternal;
extern DataColumnDefaultTypeInternal _DataColumn_default_instance_;
class DataTimestamps;
struct DataTimestampsDefaultTypeInternal;
extern DataTimestampsDefaultTypeInternal _DataTimestamps_default_instance_;
class DataValue;
struct DataValueDefaultTypeInternal;
extern DataValueDefaultTypeInternal _DataValue_default_instance_;
class DataValue_ValueStatus;
struct DataValue_ValueStatusDefaultTypeInternal;
extern DataValue_ValueStatusDefaultTypeInternal _DataValue_ValueStatus_default_instance_;
class EventMetadata;
struct EventMetadataDefaultTypeInternal;
extern EventMetadataDefaultTypeInternal _EventMetadata_default_instance_;
class ExceptionalResult;
struct ExceptionalResultDefaultTypeInternal;
extern ExceptionalResultDefaultTypeInternal _ExceptionalResult_default_instance_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class SamplingClock;
struct SamplingClockDefaultTypeInternal;
extern SamplingClockDefaultTypeInternal _SamplingClock_default_instance_;
class Structure;
struct StructureDefaultTypeInternal;
extern StructureDefaultTypeInternal _Structure_default_instance_;
class Structure_Field;
struct Structure_FieldDefaultTypeInternal;
extern Structure_FieldDefaultTypeInternal _Structure_Field_default_instance_;
class Timestamp;
struct TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class TimestampList;
struct TimestampListDefaultTypeInternal;
extern TimestampListDefaultTypeInternal _TimestampList_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Array* Arena::CreateMaybeMessage<::Array>(Arena*);
template<> ::Attribute* Arena::CreateMaybeMessage<::Attribute>(Arena*);
template<> ::DataColumn* Arena::CreateMaybeMessage<::DataColumn>(Arena*);
template<> ::DataTimestamps* Arena::CreateMaybeMessage<::DataTimestamps>(Arena*);
template<> ::DataValue* Arena::CreateMaybeMessage<::DataValue>(Arena*);
template<> ::DataValue_ValueStatus* Arena::CreateMaybeMessage<::DataValue_ValueStatus>(Arena*);
template<> ::EventMetadata* Arena::CreateMaybeMessage<::EventMetadata>(Arena*);
template<> ::ExceptionalResult* Arena::CreateMaybeMessage<::ExceptionalResult>(Arena*);
template<> ::Image* Arena::CreateMaybeMessage<::Image>(Arena*);
template<> ::SamplingClock* Arena::CreateMaybeMessage<::SamplingClock>(Arena*);
template<> ::Structure* Arena::CreateMaybeMessage<::Structure>(Arena*);
template<> ::Structure_Field* Arena::CreateMaybeMessage<::Structure_Field>(Arena*);
template<> ::Timestamp* Arena::CreateMaybeMessage<::Timestamp>(Arena*);
template<> ::TimestampList* Arena::CreateMaybeMessage<::TimestampList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum ExceptionalResult_ExceptionalResultStatus : int {
  ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_REJECT = 0,
  ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_ERROR = 1,
  ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_EMPTY = 2,
  ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_NOT_READY = 3,
  ExceptionalResult_ExceptionalResultStatus_ExceptionalResult_ExceptionalResultStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ExceptionalResult_ExceptionalResultStatus_ExceptionalResult_ExceptionalResultStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ExceptionalResult_ExceptionalResultStatus_IsValid(int value);
constexpr ExceptionalResult_ExceptionalResultStatus ExceptionalResult_ExceptionalResultStatus_ExceptionalResultStatus_MIN = ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_REJECT;
constexpr ExceptionalResult_ExceptionalResultStatus ExceptionalResult_ExceptionalResultStatus_ExceptionalResultStatus_MAX = ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_NOT_READY;
constexpr int ExceptionalResult_ExceptionalResultStatus_ExceptionalResultStatus_ARRAYSIZE = ExceptionalResult_ExceptionalResultStatus_ExceptionalResultStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExceptionalResult_ExceptionalResultStatus_descriptor();
template<typename T>
inline const std::string& ExceptionalResult_ExceptionalResultStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExceptionalResult_ExceptionalResultStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExceptionalResult_ExceptionalResultStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExceptionalResult_ExceptionalResultStatus_descriptor(), enum_t_value);
}
inline bool ExceptionalResult_ExceptionalResultStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExceptionalResult_ExceptionalResultStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExceptionalResult_ExceptionalResultStatus>(
    ExceptionalResult_ExceptionalResultStatus_descriptor(), name, value);
}
enum DataValue_ValueStatus_StatusCode : int {
  DataValue_ValueStatus_StatusCode_NO_STATUS = 0,
  DataValue_ValueStatus_StatusCode_DEVICE_STATUS = 1,
  DataValue_ValueStatus_StatusCode_DRIVER_STATUS = 2,
  DataValue_ValueStatus_StatusCode_RECORD_STATUS = 3,
  DataValue_ValueStatus_StatusCode_DB_STATUS = 4,
  DataValue_ValueStatus_StatusCode_CONF_STATUS = 5,
  DataValue_ValueStatus_StatusCode_UNDEFINED_STATUS = 6,
  DataValue_ValueStatus_StatusCode_CLIENT_STATUS = 7,
  DataValue_ValueStatus_StatusCode_DataValue_ValueStatus_StatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataValue_ValueStatus_StatusCode_DataValue_ValueStatus_StatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataValue_ValueStatus_StatusCode_IsValid(int value);
constexpr DataValue_ValueStatus_StatusCode DataValue_ValueStatus_StatusCode_StatusCode_MIN = DataValue_ValueStatus_StatusCode_NO_STATUS;
constexpr DataValue_ValueStatus_StatusCode DataValue_ValueStatus_StatusCode_StatusCode_MAX = DataValue_ValueStatus_StatusCode_CLIENT_STATUS;
constexpr int DataValue_ValueStatus_StatusCode_StatusCode_ARRAYSIZE = DataValue_ValueStatus_StatusCode_StatusCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataValue_ValueStatus_StatusCode_descriptor();
template<typename T>
inline const std::string& DataValue_ValueStatus_StatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataValue_ValueStatus_StatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataValue_ValueStatus_StatusCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataValue_ValueStatus_StatusCode_descriptor(), enum_t_value);
}
inline bool DataValue_ValueStatus_StatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataValue_ValueStatus_StatusCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataValue_ValueStatus_StatusCode>(
    DataValue_ValueStatus_StatusCode_descriptor(), name, value);
}
enum DataValue_ValueStatus_Severity : int {
  DataValue_ValueStatus_Severity_NO_ALARM = 0,
  DataValue_ValueStatus_Severity_MINOR_ALARM = 1,
  DataValue_ValueStatus_Severity_MAJOR_ALARM = 2,
  DataValue_ValueStatus_Severity_INVALID_ALARM = 3,
  DataValue_ValueStatus_Severity_UNDEFINED_ALARM = 4,
  DataValue_ValueStatus_Severity_DataValue_ValueStatus_Severity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataValue_ValueStatus_Severity_DataValue_ValueStatus_Severity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataValue_ValueStatus_Severity_IsValid(int value);
constexpr DataValue_ValueStatus_Severity DataValue_ValueStatus_Severity_Severity_MIN = DataValue_ValueStatus_Severity_NO_ALARM;
constexpr DataValue_ValueStatus_Severity DataValue_ValueStatus_Severity_Severity_MAX = DataValue_ValueStatus_Severity_UNDEFINED_ALARM;
constexpr int DataValue_ValueStatus_Severity_Severity_ARRAYSIZE = DataValue_ValueStatus_Severity_Severity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataValue_ValueStatus_Severity_descriptor();
template<typename T>
inline const std::string& DataValue_ValueStatus_Severity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataValue_ValueStatus_Severity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataValue_ValueStatus_Severity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataValue_ValueStatus_Severity_descriptor(), enum_t_value);
}
inline bool DataValue_ValueStatus_Severity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataValue_ValueStatus_Severity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataValue_ValueStatus_Severity>(
    DataValue_ValueStatus_Severity_descriptor(), name, value);
}
enum Image_FileType : int {
  Image_FileType_RAW = 0,
  Image_FileType_JPEG = 1,
  Image_FileType_GIF = 2,
  Image_FileType_TIFF = 3,
  Image_FileType_BMP = 4,
  Image_FileType_PNG = 5,
  Image_FileType_EPS = 6,
  Image_FileType_SVG = 7,
  Image_FileType_PDF = 8,
  Image_FileType_Image_FileType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Image_FileType_Image_FileType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Image_FileType_IsValid(int value);
constexpr Image_FileType Image_FileType_FileType_MIN = Image_FileType_RAW;
constexpr Image_FileType Image_FileType_FileType_MAX = Image_FileType_PDF;
constexpr int Image_FileType_FileType_ARRAYSIZE = Image_FileType_FileType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Image_FileType_descriptor();
template<typename T>
inline const std::string& Image_FileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Image_FileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Image_FileType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Image_FileType_descriptor(), enum_t_value);
}
inline bool Image_FileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Image_FileType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Image_FileType>(
    Image_FileType_descriptor(), name, value);
}
// ===================================================================

class Attribute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Attribute) */ {
 public:
  inline Attribute() : Attribute(nullptr) {}
  ~Attribute() override;
  explicit PROTOBUF_CONSTEXPR Attribute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Attribute(const Attribute& from);
  Attribute(Attribute&& from) noexcept
    : Attribute() {
    *this = ::std::move(from);
  }

  inline Attribute& operator=(const Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attribute& operator=(Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const Attribute* internal_default_instance() {
    return reinterpret_cast<const Attribute*>(
               &_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Attribute& a, Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(Attribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attribute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Attribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Attribute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Attribute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Attribute& from) {
    Attribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attribute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Attribute";
  }
  protected:
  explicit Attribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:Attribute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class EventMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EventMetadata) */ {
 public:
  inline EventMetadata() : EventMetadata(nullptr) {}
  ~EventMetadata() override;
  explicit PROTOBUF_CONSTEXPR EventMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventMetadata(const EventMetadata& from);
  EventMetadata(EventMetadata&& from) noexcept
    : EventMetadata() {
    *this = ::std::move(from);
  }

  inline EventMetadata& operator=(const EventMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventMetadata& operator=(EventMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventMetadata* internal_default_instance() {
    return reinterpret_cast<const EventMetadata*>(
               &_EventMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EventMetadata& a, EventMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(EventMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventMetadata& from) {
    EventMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EventMetadata";
  }
  protected:
  explicit EventMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 1,
    kStartTimestampFieldNumber = 2,
    kStopTimestampFieldNumber = 3,
  };
  // string description = 1;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .Timestamp startTimestamp = 2;
  bool has_starttimestamp() const;
  private:
  bool _internal_has_starttimestamp() const;
  public:
  void clear_starttimestamp();
  const ::Timestamp& starttimestamp() const;
  PROTOBUF_NODISCARD ::Timestamp* release_starttimestamp();
  ::Timestamp* mutable_starttimestamp();
  void set_allocated_starttimestamp(::Timestamp* starttimestamp);
  private:
  const ::Timestamp& _internal_starttimestamp() const;
  ::Timestamp* _internal_mutable_starttimestamp();
  public:
  void unsafe_arena_set_allocated_starttimestamp(
      ::Timestamp* starttimestamp);
  ::Timestamp* unsafe_arena_release_starttimestamp();

  // .Timestamp stopTimestamp = 3;
  bool has_stoptimestamp() const;
  private:
  bool _internal_has_stoptimestamp() const;
  public:
  void clear_stoptimestamp();
  const ::Timestamp& stoptimestamp() const;
  PROTOBUF_NODISCARD ::Timestamp* release_stoptimestamp();
  ::Timestamp* mutable_stoptimestamp();
  void set_allocated_stoptimestamp(::Timestamp* stoptimestamp);
  private:
  const ::Timestamp& _internal_stoptimestamp() const;
  ::Timestamp* _internal_mutable_stoptimestamp();
  public:
  void unsafe_arena_set_allocated_stoptimestamp(
      ::Timestamp* stoptimestamp);
  ::Timestamp* unsafe_arena_release_stoptimestamp();

  // @@protoc_insertion_point(class_scope:EventMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::Timestamp* starttimestamp_;
    ::Timestamp* stoptimestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Timestamp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Timestamp) */ {
 public:
  inline Timestamp() : Timestamp(nullptr) {}
  ~Timestamp() override;
  explicit PROTOBUF_CONSTEXPR Timestamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Timestamp(const Timestamp& from);
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Timestamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(Timestamp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Timestamp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Timestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Timestamp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Timestamp& from) {
    Timestamp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timestamp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Timestamp";
  }
  protected:
  explicit Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpochSecondsFieldNumber = 1,
    kNanosecondsFieldNumber = 2,
  };
  // uint64 epochSeconds = 1;
  void clear_epochseconds();
  uint64_t epochseconds() const;
  void set_epochseconds(uint64_t value);
  private:
  uint64_t _internal_epochseconds() const;
  void _internal_set_epochseconds(uint64_t value);
  public:

  // uint64 nanoseconds = 2;
  void clear_nanoseconds();
  uint64_t nanoseconds() const;
  void set_nanoseconds(uint64_t value);
  private:
  uint64_t _internal_nanoseconds() const;
  void _internal_set_nanoseconds(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Timestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t epochseconds_;
    uint64_t nanoseconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class TimestampList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TimestampList) */ {
 public:
  inline TimestampList() : TimestampList(nullptr) {}
  ~TimestampList() override;
  explicit PROTOBUF_CONSTEXPR TimestampList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimestampList(const TimestampList& from);
  TimestampList(TimestampList&& from) noexcept
    : TimestampList() {
    *this = ::std::move(from);
  }

  inline TimestampList& operator=(const TimestampList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimestampList& operator=(TimestampList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimestampList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimestampList* internal_default_instance() {
    return reinterpret_cast<const TimestampList*>(
               &_TimestampList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TimestampList& a, TimestampList& b) {
    a.Swap(&b);
  }
  inline void Swap(TimestampList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimestampList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimestampList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimestampList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimestampList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimestampList& from) {
    TimestampList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimestampList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TimestampList";
  }
  protected:
  explicit TimestampList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampsFieldNumber = 1,
  };
  // repeated .Timestamp timestamps = 1;
  int timestamps_size() const;
  private:
  int _internal_timestamps_size() const;
  public:
  void clear_timestamps();
  ::Timestamp* mutable_timestamps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Timestamp >*
      mutable_timestamps();
  private:
  const ::Timestamp& _internal_timestamps(int index) const;
  ::Timestamp* _internal_add_timestamps();
  public:
  const ::Timestamp& timestamps(int index) const;
  ::Timestamp* add_timestamps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Timestamp >&
      timestamps() const;

  // @@protoc_insertion_point(class_scope:TimestampList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Timestamp > timestamps_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class SamplingClock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SamplingClock) */ {
 public:
  inline SamplingClock() : SamplingClock(nullptr) {}
  ~SamplingClock() override;
  explicit PROTOBUF_CONSTEXPR SamplingClock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SamplingClock(const SamplingClock& from);
  SamplingClock(SamplingClock&& from) noexcept
    : SamplingClock() {
    *this = ::std::move(from);
  }

  inline SamplingClock& operator=(const SamplingClock& from) {
    CopyFrom(from);
    return *this;
  }
  inline SamplingClock& operator=(SamplingClock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SamplingClock& default_instance() {
    return *internal_default_instance();
  }
  static inline const SamplingClock* internal_default_instance() {
    return reinterpret_cast<const SamplingClock*>(
               &_SamplingClock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SamplingClock& a, SamplingClock& b) {
    a.Swap(&b);
  }
  inline void Swap(SamplingClock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SamplingClock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SamplingClock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SamplingClock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SamplingClock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SamplingClock& from) {
    SamplingClock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SamplingClock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SamplingClock";
  }
  protected:
  explicit SamplingClock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 1,
    kPeriodNanosFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // .Timestamp startTime = 1;
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;
  public:
  void clear_starttime();
  const ::Timestamp& starttime() const;
  PROTOBUF_NODISCARD ::Timestamp* release_starttime();
  ::Timestamp* mutable_starttime();
  void set_allocated_starttime(::Timestamp* starttime);
  private:
  const ::Timestamp& _internal_starttime() const;
  ::Timestamp* _internal_mutable_starttime();
  public:
  void unsafe_arena_set_allocated_starttime(
      ::Timestamp* starttime);
  ::Timestamp* unsafe_arena_release_starttime();

  // uint64 periodNanos = 2;
  void clear_periodnanos();
  uint64_t periodnanos() const;
  void set_periodnanos(uint64_t value);
  private:
  uint64_t _internal_periodnanos() const;
  void _internal_set_periodnanos(uint64_t value);
  public:

  // uint32 count = 3;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SamplingClock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Timestamp* starttime_;
    uint64_t periodnanos_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class DataTimestamps final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DataTimestamps) */ {
 public:
  inline DataTimestamps() : DataTimestamps(nullptr) {}
  ~DataTimestamps() override;
  explicit PROTOBUF_CONSTEXPR DataTimestamps(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataTimestamps(const DataTimestamps& from);
  DataTimestamps(DataTimestamps&& from) noexcept
    : DataTimestamps() {
    *this = ::std::move(from);
  }

  inline DataTimestamps& operator=(const DataTimestamps& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataTimestamps& operator=(DataTimestamps&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataTimestamps& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kSamplingClock = 1,
    kTimestampList = 2,
    VALUE_NOT_SET = 0,
  };

  static inline const DataTimestamps* internal_default_instance() {
    return reinterpret_cast<const DataTimestamps*>(
               &_DataTimestamps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DataTimestamps& a, DataTimestamps& b) {
    a.Swap(&b);
  }
  inline void Swap(DataTimestamps* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataTimestamps* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataTimestamps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataTimestamps>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataTimestamps& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataTimestamps& from) {
    DataTimestamps::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataTimestamps* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DataTimestamps";
  }
  protected:
  explicit DataTimestamps(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSamplingClockFieldNumber = 1,
    kTimestampListFieldNumber = 2,
  };
  // .SamplingClock samplingClock = 1;
  bool has_samplingclock() const;
  private:
  bool _internal_has_samplingclock() const;
  public:
  void clear_samplingclock();
  const ::SamplingClock& samplingclock() const;
  PROTOBUF_NODISCARD ::SamplingClock* release_samplingclock();
  ::SamplingClock* mutable_samplingclock();
  void set_allocated_samplingclock(::SamplingClock* samplingclock);
  private:
  const ::SamplingClock& _internal_samplingclock() const;
  ::SamplingClock* _internal_mutable_samplingclock();
  public:
  void unsafe_arena_set_allocated_samplingclock(
      ::SamplingClock* samplingclock);
  ::SamplingClock* unsafe_arena_release_samplingclock();

  // .TimestampList timestampList = 2;
  bool has_timestamplist() const;
  private:
  bool _internal_has_timestamplist() const;
  public:
  void clear_timestamplist();
  const ::TimestampList& timestamplist() const;
  PROTOBUF_NODISCARD ::TimestampList* release_timestamplist();
  ::TimestampList* mutable_timestamplist();
  void set_allocated_timestamplist(::TimestampList* timestamplist);
  private:
  const ::TimestampList& _internal_timestamplist() const;
  ::TimestampList* _internal_mutable_timestamplist();
  public:
  void unsafe_arena_set_allocated_timestamplist(
      ::TimestampList* timestamplist);
  ::TimestampList* unsafe_arena_release_timestamplist();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:DataTimestamps)
 private:
  class _Internal;
  void set_has_samplingclock();
  void set_has_timestamplist();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::SamplingClock* samplingclock_;
      ::TimestampList* timestamplist_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ExceptionalResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ExceptionalResult) */ {
 public:
  inline ExceptionalResult() : ExceptionalResult(nullptr) {}
  ~ExceptionalResult() override;
  explicit PROTOBUF_CONSTEXPR ExceptionalResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExceptionalResult(const ExceptionalResult& from);
  ExceptionalResult(ExceptionalResult&& from) noexcept
    : ExceptionalResult() {
    *this = ::std::move(from);
  }

  inline ExceptionalResult& operator=(const ExceptionalResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExceptionalResult& operator=(ExceptionalResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExceptionalResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExceptionalResult* internal_default_instance() {
    return reinterpret_cast<const ExceptionalResult*>(
               &_ExceptionalResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ExceptionalResult& a, ExceptionalResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ExceptionalResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExceptionalResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExceptionalResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExceptionalResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExceptionalResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExceptionalResult& from) {
    ExceptionalResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExceptionalResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ExceptionalResult";
  }
  protected:
  explicit ExceptionalResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ExceptionalResult_ExceptionalResultStatus ExceptionalResultStatus;
  static constexpr ExceptionalResultStatus RESULT_STATUS_REJECT =
    ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_REJECT;
  static constexpr ExceptionalResultStatus RESULT_STATUS_ERROR =
    ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_ERROR;
  static constexpr ExceptionalResultStatus RESULT_STATUS_EMPTY =
    ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_EMPTY;
  static constexpr ExceptionalResultStatus RESULT_STATUS_NOT_READY =
    ExceptionalResult_ExceptionalResultStatus_RESULT_STATUS_NOT_READY;
  static inline bool ExceptionalResultStatus_IsValid(int value) {
    return ExceptionalResult_ExceptionalResultStatus_IsValid(value);
  }
  static constexpr ExceptionalResultStatus ExceptionalResultStatus_MIN =
    ExceptionalResult_ExceptionalResultStatus_ExceptionalResultStatus_MIN;
  static constexpr ExceptionalResultStatus ExceptionalResultStatus_MAX =
    ExceptionalResult_ExceptionalResultStatus_ExceptionalResultStatus_MAX;
  static constexpr int ExceptionalResultStatus_ARRAYSIZE =
    ExceptionalResult_ExceptionalResultStatus_ExceptionalResultStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ExceptionalResultStatus_descriptor() {
    return ExceptionalResult_ExceptionalResultStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& ExceptionalResultStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ExceptionalResultStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ExceptionalResultStatus_Name.");
    return ExceptionalResult_ExceptionalResultStatus_Name(enum_t_value);
  }
  static inline bool ExceptionalResultStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ExceptionalResultStatus* value) {
    return ExceptionalResult_ExceptionalResultStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kExceptionalResultStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .ExceptionalResult.ExceptionalResultStatus exceptionalResultStatus = 1;
  void clear_exceptionalresultstatus();
  ::ExceptionalResult_ExceptionalResultStatus exceptionalresultstatus() const;
  void set_exceptionalresultstatus(::ExceptionalResult_ExceptionalResultStatus value);
  private:
  ::ExceptionalResult_ExceptionalResultStatus _internal_exceptionalresultstatus() const;
  void _internal_set_exceptionalresultstatus(::ExceptionalResult_ExceptionalResultStatus value);
  public:

  // @@protoc_insertion_point(class_scope:ExceptionalResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int exceptionalresultstatus_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class DataColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DataColumn) */ {
 public:
  inline DataColumn() : DataColumn(nullptr) {}
  ~DataColumn() override;
  explicit PROTOBUF_CONSTEXPR DataColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataColumn(const DataColumn& from);
  DataColumn(DataColumn&& from) noexcept
    : DataColumn() {
    *this = ::std::move(from);
  }

  inline DataColumn& operator=(const DataColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataColumn& operator=(DataColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataColumn* internal_default_instance() {
    return reinterpret_cast<const DataColumn*>(
               &_DataColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DataColumn& a, DataColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(DataColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataColumn& from) {
    DataColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DataColumn";
  }
  protected:
  explicit DataColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataValuesFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .DataValue dataValues = 2;
  int datavalues_size() const;
  private:
  int _internal_datavalues_size() const;
  public:
  void clear_datavalues();
  ::DataValue* mutable_datavalues(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataValue >*
      mutable_datavalues();
  private:
  const ::DataValue& _internal_datavalues(int index) const;
  ::DataValue* _internal_add_datavalues();
  public:
  const ::DataValue& datavalues(int index) const;
  ::DataValue* add_datavalues();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataValue >&
      datavalues() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:DataColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataValue > datavalues_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class DataValue_ValueStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DataValue.ValueStatus) */ {
 public:
  inline DataValue_ValueStatus() : DataValue_ValueStatus(nullptr) {}
  ~DataValue_ValueStatus() override;
  explicit PROTOBUF_CONSTEXPR DataValue_ValueStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataValue_ValueStatus(const DataValue_ValueStatus& from);
  DataValue_ValueStatus(DataValue_ValueStatus&& from) noexcept
    : DataValue_ValueStatus() {
    *this = ::std::move(from);
  }

  inline DataValue_ValueStatus& operator=(const DataValue_ValueStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataValue_ValueStatus& operator=(DataValue_ValueStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataValue_ValueStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataValue_ValueStatus* internal_default_instance() {
    return reinterpret_cast<const DataValue_ValueStatus*>(
               &_DataValue_ValueStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DataValue_ValueStatus& a, DataValue_ValueStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(DataValue_ValueStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataValue_ValueStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataValue_ValueStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataValue_ValueStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataValue_ValueStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataValue_ValueStatus& from) {
    DataValue_ValueStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataValue_ValueStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DataValue.ValueStatus";
  }
  protected:
  explicit DataValue_ValueStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataValue_ValueStatus_StatusCode StatusCode;
  static constexpr StatusCode NO_STATUS =
    DataValue_ValueStatus_StatusCode_NO_STATUS;
  static constexpr StatusCode DEVICE_STATUS =
    DataValue_ValueStatus_StatusCode_DEVICE_STATUS;
  static constexpr StatusCode DRIVER_STATUS =
    DataValue_ValueStatus_StatusCode_DRIVER_STATUS;
  static constexpr StatusCode RECORD_STATUS =
    DataValue_ValueStatus_StatusCode_RECORD_STATUS;
  static constexpr StatusCode DB_STATUS =
    DataValue_ValueStatus_StatusCode_DB_STATUS;
  static constexpr StatusCode CONF_STATUS =
    DataValue_ValueStatus_StatusCode_CONF_STATUS;
  static constexpr StatusCode UNDEFINED_STATUS =
    DataValue_ValueStatus_StatusCode_UNDEFINED_STATUS;
  static constexpr StatusCode CLIENT_STATUS =
    DataValue_ValueStatus_StatusCode_CLIENT_STATUS;
  static inline bool StatusCode_IsValid(int value) {
    return DataValue_ValueStatus_StatusCode_IsValid(value);
  }
  static constexpr StatusCode StatusCode_MIN =
    DataValue_ValueStatus_StatusCode_StatusCode_MIN;
  static constexpr StatusCode StatusCode_MAX =
    DataValue_ValueStatus_StatusCode_StatusCode_MAX;
  static constexpr int StatusCode_ARRAYSIZE =
    DataValue_ValueStatus_StatusCode_StatusCode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StatusCode_descriptor() {
    return DataValue_ValueStatus_StatusCode_descriptor();
  }
  template<typename T>
  static inline const std::string& StatusCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StatusCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StatusCode_Name.");
    return DataValue_ValueStatus_StatusCode_Name(enum_t_value);
  }
  static inline bool StatusCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StatusCode* value) {
    return DataValue_ValueStatus_StatusCode_Parse(name, value);
  }

  typedef DataValue_ValueStatus_Severity Severity;
  static constexpr Severity NO_ALARM =
    DataValue_ValueStatus_Severity_NO_ALARM;
  static constexpr Severity MINOR_ALARM =
    DataValue_ValueStatus_Severity_MINOR_ALARM;
  static constexpr Severity MAJOR_ALARM =
    DataValue_ValueStatus_Severity_MAJOR_ALARM;
  static constexpr Severity INVALID_ALARM =
    DataValue_ValueStatus_Severity_INVALID_ALARM;
  static constexpr Severity UNDEFINED_ALARM =
    DataValue_ValueStatus_Severity_UNDEFINED_ALARM;
  static inline bool Severity_IsValid(int value) {
    return DataValue_ValueStatus_Severity_IsValid(value);
  }
  static constexpr Severity Severity_MIN =
    DataValue_ValueStatus_Severity_Severity_MIN;
  static constexpr Severity Severity_MAX =
    DataValue_ValueStatus_Severity_Severity_MAX;
  static constexpr int Severity_ARRAYSIZE =
    DataValue_ValueStatus_Severity_Severity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Severity_descriptor() {
    return DataValue_ValueStatus_Severity_descriptor();
  }
  template<typename T>
  static inline const std::string& Severity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Severity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Severity_Name.");
    return DataValue_ValueStatus_Severity_Name(enum_t_value);
  }
  static inline bool Severity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Severity* value) {
    return DataValue_ValueStatus_Severity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kStatusCodeFieldNumber = 2,
    kSeverityFieldNumber = 3,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .DataValue.ValueStatus.StatusCode statusCode = 2;
  void clear_statuscode();
  ::DataValue_ValueStatus_StatusCode statuscode() const;
  void set_statuscode(::DataValue_ValueStatus_StatusCode value);
  private:
  ::DataValue_ValueStatus_StatusCode _internal_statuscode() const;
  void _internal_set_statuscode(::DataValue_ValueStatus_StatusCode value);
  public:

  // .DataValue.ValueStatus.Severity severity = 3;
  void clear_severity();
  ::DataValue_ValueStatus_Severity severity() const;
  void set_severity(::DataValue_ValueStatus_Severity value);
  private:
  ::DataValue_ValueStatus_Severity _internal_severity() const;
  void _internal_set_severity(::DataValue_ValueStatus_Severity value);
  public:

  // @@protoc_insertion_point(class_scope:DataValue.ValueStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int statuscode_;
    int severity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class DataValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DataValue) */ {
 public:
  inline DataValue() : DataValue(nullptr) {}
  ~DataValue() override;
  explicit PROTOBUF_CONSTEXPR DataValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataValue(const DataValue& from);
  DataValue(DataValue&& from) noexcept
    : DataValue() {
    *this = ::std::move(from);
  }

  inline DataValue& operator=(const DataValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataValue& operator=(DataValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataValue& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kStringValue = 1,
    kBooleanValue = 2,
    kUintValue = 3,
    kUlongValue = 4,
    kIntValue = 5,
    kLongValue = 6,
    kFloatValue = 7,
    kDoubleValue = 8,
    kByteArrayValue = 9,
    kArrayValue = 10,
    kStructureValue = 11,
    kImageValue = 12,
    kTimestampValue = 13,
    VALUE_NOT_SET = 0,
  };

  static inline const DataValue* internal_default_instance() {
    return reinterpret_cast<const DataValue*>(
               &_DataValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DataValue& a, DataValue& b) {
    a.Swap(&b);
  }
  inline void Swap(DataValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataValue& from) {
    DataValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DataValue";
  }
  protected:
  explicit DataValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataValue_ValueStatus ValueStatus;

  // accessors -------------------------------------------------------

  enum : int {
    kValueStatusFieldNumber = 15,
    kStringValueFieldNumber = 1,
    kBooleanValueFieldNumber = 2,
    kUintValueFieldNumber = 3,
    kUlongValueFieldNumber = 4,
    kIntValueFieldNumber = 5,
    kLongValueFieldNumber = 6,
    kFloatValueFieldNumber = 7,
    kDoubleValueFieldNumber = 8,
    kByteArrayValueFieldNumber = 9,
    kArrayValueFieldNumber = 10,
    kStructureValueFieldNumber = 11,
    kImageValueFieldNumber = 12,
    kTimestampValueFieldNumber = 13,
  };
  // .DataValue.ValueStatus valueStatus = 15;
  bool has_valuestatus() const;
  private:
  bool _internal_has_valuestatus() const;
  public:
  void clear_valuestatus();
  const ::DataValue_ValueStatus& valuestatus() const;
  PROTOBUF_NODISCARD ::DataValue_ValueStatus* release_valuestatus();
  ::DataValue_ValueStatus* mutable_valuestatus();
  void set_allocated_valuestatus(::DataValue_ValueStatus* valuestatus);
  private:
  const ::DataValue_ValueStatus& _internal_valuestatus() const;
  ::DataValue_ValueStatus* _internal_mutable_valuestatus();
  public:
  void unsafe_arena_set_allocated_valuestatus(
      ::DataValue_ValueStatus* valuestatus);
  ::DataValue_ValueStatus* unsafe_arena_release_valuestatus();

  // string stringValue = 1;
  bool has_stringvalue() const;
  private:
  bool _internal_has_stringvalue() const;
  public:
  void clear_stringvalue();
  const std::string& stringvalue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stringvalue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stringvalue();
  PROTOBUF_NODISCARD std::string* release_stringvalue();
  void set_allocated_stringvalue(std::string* stringvalue);
  private:
  const std::string& _internal_stringvalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stringvalue(const std::string& value);
  std::string* _internal_mutable_stringvalue();
  public:

  // bool booleanValue = 2;
  bool has_booleanvalue() const;
  private:
  bool _internal_has_booleanvalue() const;
  public:
  void clear_booleanvalue();
  bool booleanvalue() const;
  void set_booleanvalue(bool value);
  private:
  bool _internal_booleanvalue() const;
  void _internal_set_booleanvalue(bool value);
  public:

  // uint32 uintValue = 3;
  bool has_uintvalue() const;
  private:
  bool _internal_has_uintvalue() const;
  public:
  void clear_uintvalue();
  uint32_t uintvalue() const;
  void set_uintvalue(uint32_t value);
  private:
  uint32_t _internal_uintvalue() const;
  void _internal_set_uintvalue(uint32_t value);
  public:

  // uint64 ulongValue = 4;
  bool has_ulongvalue() const;
  private:
  bool _internal_has_ulongvalue() const;
  public:
  void clear_ulongvalue();
  uint64_t ulongvalue() const;
  void set_ulongvalue(uint64_t value);
  private:
  uint64_t _internal_ulongvalue() const;
  void _internal_set_ulongvalue(uint64_t value);
  public:

  // sint32 intValue = 5;
  bool has_intvalue() const;
  private:
  bool _internal_has_intvalue() const;
  public:
  void clear_intvalue();
  int32_t intvalue() const;
  void set_intvalue(int32_t value);
  private:
  int32_t _internal_intvalue() const;
  void _internal_set_intvalue(int32_t value);
  public:

  // sint64 longValue = 6;
  bool has_longvalue() const;
  private:
  bool _internal_has_longvalue() const;
  public:
  void clear_longvalue();
  int64_t longvalue() const;
  void set_longvalue(int64_t value);
  private:
  int64_t _internal_longvalue() const;
  void _internal_set_longvalue(int64_t value);
  public:

  // float floatValue = 7;
  bool has_floatvalue() const;
  private:
  bool _internal_has_floatvalue() const;
  public:
  void clear_floatvalue();
  float floatvalue() const;
  void set_floatvalue(float value);
  private:
  float _internal_floatvalue() const;
  void _internal_set_floatvalue(float value);
  public:

  // double doubleValue = 8;
  bool has_doublevalue() const;
  private:
  bool _internal_has_doublevalue() const;
  public:
  void clear_doublevalue();
  double doublevalue() const;
  void set_doublevalue(double value);
  private:
  double _internal_doublevalue() const;
  void _internal_set_doublevalue(double value);
  public:

  // bytes byteArrayValue = 9;
  bool has_bytearrayvalue() const;
  private:
  bool _internal_has_bytearrayvalue() const;
  public:
  void clear_bytearrayvalue();
  const std::string& bytearrayvalue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bytearrayvalue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bytearrayvalue();
  PROTOBUF_NODISCARD std::string* release_bytearrayvalue();
  void set_allocated_bytearrayvalue(std::string* bytearrayvalue);
  private:
  const std::string& _internal_bytearrayvalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bytearrayvalue(const std::string& value);
  std::string* _internal_mutable_bytearrayvalue();
  public:

  // .Array arrayValue = 10;
  bool has_arrayvalue() const;
  private:
  bool _internal_has_arrayvalue() const;
  public:
  void clear_arrayvalue();
  const ::Array& arrayvalue() const;
  PROTOBUF_NODISCARD ::Array* release_arrayvalue();
  ::Array* mutable_arrayvalue();
  void set_allocated_arrayvalue(::Array* arrayvalue);
  private:
  const ::Array& _internal_arrayvalue() const;
  ::Array* _internal_mutable_arrayvalue();
  public:
  void unsafe_arena_set_allocated_arrayvalue(
      ::Array* arrayvalue);
  ::Array* unsafe_arena_release_arrayvalue();

  // .Structure structureValue = 11;
  bool has_structurevalue() const;
  private:
  bool _internal_has_structurevalue() const;
  public:
  void clear_structurevalue();
  const ::Structure& structurevalue() const;
  PROTOBUF_NODISCARD ::Structure* release_structurevalue();
  ::Structure* mutable_structurevalue();
  void set_allocated_structurevalue(::Structure* structurevalue);
  private:
  const ::Structure& _internal_structurevalue() const;
  ::Structure* _internal_mutable_structurevalue();
  public:
  void unsafe_arena_set_allocated_structurevalue(
      ::Structure* structurevalue);
  ::Structure* unsafe_arena_release_structurevalue();

  // .Image imageValue = 12;
  bool has_imagevalue() const;
  private:
  bool _internal_has_imagevalue() const;
  public:
  void clear_imagevalue();
  const ::Image& imagevalue() const;
  PROTOBUF_NODISCARD ::Image* release_imagevalue();
  ::Image* mutable_imagevalue();
  void set_allocated_imagevalue(::Image* imagevalue);
  private:
  const ::Image& _internal_imagevalue() const;
  ::Image* _internal_mutable_imagevalue();
  public:
  void unsafe_arena_set_allocated_imagevalue(
      ::Image* imagevalue);
  ::Image* unsafe_arena_release_imagevalue();

  // .Timestamp timestampValue = 13;
  bool has_timestampvalue() const;
  private:
  bool _internal_has_timestampvalue() const;
  public:
  void clear_timestampvalue();
  const ::Timestamp& timestampvalue() const;
  PROTOBUF_NODISCARD ::Timestamp* release_timestampvalue();
  ::Timestamp* mutable_timestampvalue();
  void set_allocated_timestampvalue(::Timestamp* timestampvalue);
  private:
  const ::Timestamp& _internal_timestampvalue() const;
  ::Timestamp* _internal_mutable_timestampvalue();
  public:
  void unsafe_arena_set_allocated_timestampvalue(
      ::Timestamp* timestampvalue);
  ::Timestamp* unsafe_arena_release_timestampvalue();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:DataValue)
 private:
  class _Internal;
  void set_has_stringvalue();
  void set_has_booleanvalue();
  void set_has_uintvalue();
  void set_has_ulongvalue();
  void set_has_intvalue();
  void set_has_longvalue();
  void set_has_floatvalue();
  void set_has_doublevalue();
  void set_has_bytearrayvalue();
  void set_has_arrayvalue();
  void set_has_structurevalue();
  void set_has_imagevalue();
  void set_has_timestampvalue();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::DataValue_ValueStatus* valuestatus_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stringvalue_;
      bool booleanvalue_;
      uint32_t uintvalue_;
      uint64_t ulongvalue_;
      int32_t intvalue_;
      int64_t longvalue_;
      float floatvalue_;
      double doublevalue_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytearrayvalue_;
      ::Array* arrayvalue_;
      ::Structure* structurevalue_;
      ::Image* imagevalue_;
      ::Timestamp* timestampvalue_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Structure_Field final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Structure.Field) */ {
 public:
  inline Structure_Field() : Structure_Field(nullptr) {}
  ~Structure_Field() override;
  explicit PROTOBUF_CONSTEXPR Structure_Field(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Structure_Field(const Structure_Field& from);
  Structure_Field(Structure_Field&& from) noexcept
    : Structure_Field() {
    *this = ::std::move(from);
  }

  inline Structure_Field& operator=(const Structure_Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline Structure_Field& operator=(Structure_Field&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Structure_Field& default_instance() {
    return *internal_default_instance();
  }
  static inline const Structure_Field* internal_default_instance() {
    return reinterpret_cast<const Structure_Field*>(
               &_Structure_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Structure_Field& a, Structure_Field& b) {
    a.Swap(&b);
  }
  inline void Swap(Structure_Field* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Structure_Field* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Structure_Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Structure_Field>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Structure_Field& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Structure_Field& from) {
    Structure_Field::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Structure_Field* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Structure.Field";
  }
  protected:
  explicit Structure_Field(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .DataValue value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::DataValue& value() const;
  PROTOBUF_NODISCARD ::DataValue* release_value();
  ::DataValue* mutable_value();
  void set_allocated_value(::DataValue* value);
  private:
  const ::DataValue& _internal_value() const;
  ::DataValue* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::DataValue* value);
  ::DataValue* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:Structure.Field)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::DataValue* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Structure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Structure) */ {
 public:
  inline Structure() : Structure(nullptr) {}
  ~Structure() override;
  explicit PROTOBUF_CONSTEXPR Structure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Structure(const Structure& from);
  Structure(Structure&& from) noexcept
    : Structure() {
    *this = ::std::move(from);
  }

  inline Structure& operator=(const Structure& from) {
    CopyFrom(from);
    return *this;
  }
  inline Structure& operator=(Structure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Structure& default_instance() {
    return *internal_default_instance();
  }
  static inline const Structure* internal_default_instance() {
    return reinterpret_cast<const Structure*>(
               &_Structure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Structure& a, Structure& b) {
    a.Swap(&b);
  }
  inline void Swap(Structure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Structure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Structure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Structure>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Structure& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Structure& from) {
    Structure::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Structure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Structure";
  }
  protected:
  explicit Structure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Structure_Field Field;

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 1,
  };
  // repeated .Structure.Field fields = 1;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::Structure_Field* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Structure_Field >*
      mutable_fields();
  private:
  const ::Structure_Field& _internal_fields(int index) const;
  ::Structure_Field* _internal_add_fields();
  public:
  const ::Structure_Field& fields(int index) const;
  ::Structure_Field* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Structure_Field >&
      fields() const;

  // @@protoc_insertion_point(class_scope:Structure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Structure_Field > fields_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Array final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Array) */ {
 public:
  inline Array() : Array(nullptr) {}
  ~Array() override;
  explicit PROTOBUF_CONSTEXPR Array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Array(const Array& from);
  Array(Array&& from) noexcept
    : Array() {
    *this = ::std::move(from);
  }

  inline Array& operator=(const Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Array& operator=(Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Array* internal_default_instance() {
    return reinterpret_cast<const Array*>(
               &_Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Array& a, Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Array>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Array& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Array& from) {
    Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Array";
  }
  protected:
  explicit Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataValuesFieldNumber = 1,
  };
  // repeated .DataValue dataValues = 1;
  int datavalues_size() const;
  private:
  int _internal_datavalues_size() const;
  public:
  void clear_datavalues();
  ::DataValue* mutable_datavalues(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataValue >*
      mutable_datavalues();
  private:
  const ::DataValue& _internal_datavalues(int index) const;
  ::DataValue* _internal_add_datavalues();
  public:
  const ::DataValue& datavalues(int index) const;
  ::DataValue* add_datavalues();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataValue >&
      datavalues() const;

  // @@protoc_insertion_point(class_scope:Array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataValue > datavalues_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Image final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  ~Image() override;
  explicit PROTOBUF_CONSTEXPR Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Image& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Image& from) {
    Image::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Image_FileType FileType;
  static constexpr FileType RAW =
    Image_FileType_RAW;
  static constexpr FileType JPEG =
    Image_FileType_JPEG;
  static constexpr FileType GIF =
    Image_FileType_GIF;
  static constexpr FileType TIFF =
    Image_FileType_TIFF;
  static constexpr FileType BMP =
    Image_FileType_BMP;
  static constexpr FileType PNG =
    Image_FileType_PNG;
  static constexpr FileType EPS =
    Image_FileType_EPS;
  static constexpr FileType SVG =
    Image_FileType_SVG;
  static constexpr FileType PDF =
    Image_FileType_PDF;
  static inline bool FileType_IsValid(int value) {
    return Image_FileType_IsValid(value);
  }
  static constexpr FileType FileType_MIN =
    Image_FileType_FileType_MIN;
  static constexpr FileType FileType_MAX =
    Image_FileType_FileType_MAX;
  static constexpr int FileType_ARRAYSIZE =
    Image_FileType_FileType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FileType_descriptor() {
    return Image_FileType_descriptor();
  }
  template<typename T>
  static inline const std::string& FileType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FileType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FileType_Name.");
    return Image_FileType_Name(enum_t_value);
  }
  static inline bool FileType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FileType* value) {
    return Image_FileType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 1,
    kFileTypeFieldNumber = 2,
  };
  // bytes image = 1;
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // .Image.FileType fileType = 2;
  void clear_filetype();
  ::Image_FileType filetype() const;
  void set_filetype(::Image_FileType value);
  private:
  ::Image_FileType _internal_filetype() const;
  void _internal_set_filetype(::Image_FileType value);
  public:

  // @@protoc_insertion_point(class_scope:Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
    int filetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Attribute

// string name = 1;
inline void Attribute::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Attribute::name() const {
  // @@protoc_insertion_point(field_get:Attribute.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attribute::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Attribute.name)
}
inline std::string* Attribute::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Attribute.name)
  return _s;
}
inline const std::string& Attribute::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Attribute::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Attribute::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Attribute::release_name() {
  // @@protoc_insertion_point(field_release:Attribute.name)
  return _impl_.name_.Release();
}
inline void Attribute::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Attribute.name)
}

// string value = 2;
inline void Attribute::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Attribute::value() const {
  // @@protoc_insertion_point(field_get:Attribute.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attribute::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Attribute.value)
}
inline std::string* Attribute::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:Attribute.value)
  return _s;
}
inline const std::string& Attribute::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Attribute::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Attribute::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Attribute::release_value() {
  // @@protoc_insertion_point(field_release:Attribute.value)
  return _impl_.value_.Release();
}
inline void Attribute::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Attribute.value)
}

// -------------------------------------------------------------------

// EventMetadata

// string description = 1;
inline void EventMetadata::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& EventMetadata::description() const {
  // @@protoc_insertion_point(field_get:EventMetadata.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventMetadata::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EventMetadata.description)
}
inline std::string* EventMetadata::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:EventMetadata.description)
  return _s;
}
inline const std::string& EventMetadata::_internal_description() const {
  return _impl_.description_.Get();
}
inline void EventMetadata::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* EventMetadata::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* EventMetadata::release_description() {
  // @@protoc_insertion_point(field_release:EventMetadata.description)
  return _impl_.description_.Release();
}
inline void EventMetadata::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EventMetadata.description)
}

// .Timestamp startTimestamp = 2;
inline bool EventMetadata::_internal_has_starttimestamp() const {
  return this != internal_default_instance() && _impl_.starttimestamp_ != nullptr;
}
inline bool EventMetadata::has_starttimestamp() const {
  return _internal_has_starttimestamp();
}
inline void EventMetadata::clear_starttimestamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.starttimestamp_ != nullptr) {
    delete _impl_.starttimestamp_;
  }
  _impl_.starttimestamp_ = nullptr;
}
inline const ::Timestamp& EventMetadata::_internal_starttimestamp() const {
  const ::Timestamp* p = _impl_.starttimestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::Timestamp&>(
      ::_Timestamp_default_instance_);
}
inline const ::Timestamp& EventMetadata::starttimestamp() const {
  // @@protoc_insertion_point(field_get:EventMetadata.startTimestamp)
  return _internal_starttimestamp();
}
inline void EventMetadata::unsafe_arena_set_allocated_starttimestamp(
    ::Timestamp* starttimestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttimestamp_);
  }
  _impl_.starttimestamp_ = starttimestamp;
  if (starttimestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EventMetadata.startTimestamp)
}
inline ::Timestamp* EventMetadata::release_starttimestamp() {
  
  ::Timestamp* temp = _impl_.starttimestamp_;
  _impl_.starttimestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Timestamp* EventMetadata::unsafe_arena_release_starttimestamp() {
  // @@protoc_insertion_point(field_release:EventMetadata.startTimestamp)
  
  ::Timestamp* temp = _impl_.starttimestamp_;
  _impl_.starttimestamp_ = nullptr;
  return temp;
}
inline ::Timestamp* EventMetadata::_internal_mutable_starttimestamp() {
  
  if (_impl_.starttimestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::Timestamp>(GetArenaForAllocation());
    _impl_.starttimestamp_ = p;
  }
  return _impl_.starttimestamp_;
}
inline ::Timestamp* EventMetadata::mutable_starttimestamp() {
  ::Timestamp* _msg = _internal_mutable_starttimestamp();
  // @@protoc_insertion_point(field_mutable:EventMetadata.startTimestamp)
  return _msg;
}
inline void EventMetadata::set_allocated_starttimestamp(::Timestamp* starttimestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.starttimestamp_;
  }
  if (starttimestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(starttimestamp);
    if (message_arena != submessage_arena) {
      starttimestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttimestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.starttimestamp_ = starttimestamp;
  // @@protoc_insertion_point(field_set_allocated:EventMetadata.startTimestamp)
}

// .Timestamp stopTimestamp = 3;
inline bool EventMetadata::_internal_has_stoptimestamp() const {
  return this != internal_default_instance() && _impl_.stoptimestamp_ != nullptr;
}
inline bool EventMetadata::has_stoptimestamp() const {
  return _internal_has_stoptimestamp();
}
inline void EventMetadata::clear_stoptimestamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.stoptimestamp_ != nullptr) {
    delete _impl_.stoptimestamp_;
  }
  _impl_.stoptimestamp_ = nullptr;
}
inline const ::Timestamp& EventMetadata::_internal_stoptimestamp() const {
  const ::Timestamp* p = _impl_.stoptimestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::Timestamp&>(
      ::_Timestamp_default_instance_);
}
inline const ::Timestamp& EventMetadata::stoptimestamp() const {
  // @@protoc_insertion_point(field_get:EventMetadata.stopTimestamp)
  return _internal_stoptimestamp();
}
inline void EventMetadata::unsafe_arena_set_allocated_stoptimestamp(
    ::Timestamp* stoptimestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stoptimestamp_);
  }
  _impl_.stoptimestamp_ = stoptimestamp;
  if (stoptimestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EventMetadata.stopTimestamp)
}
inline ::Timestamp* EventMetadata::release_stoptimestamp() {
  
  ::Timestamp* temp = _impl_.stoptimestamp_;
  _impl_.stoptimestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Timestamp* EventMetadata::unsafe_arena_release_stoptimestamp() {
  // @@protoc_insertion_point(field_release:EventMetadata.stopTimestamp)
  
  ::Timestamp* temp = _impl_.stoptimestamp_;
  _impl_.stoptimestamp_ = nullptr;
  return temp;
}
inline ::Timestamp* EventMetadata::_internal_mutable_stoptimestamp() {
  
  if (_impl_.stoptimestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::Timestamp>(GetArenaForAllocation());
    _impl_.stoptimestamp_ = p;
  }
  return _impl_.stoptimestamp_;
}
inline ::Timestamp* EventMetadata::mutable_stoptimestamp() {
  ::Timestamp* _msg = _internal_mutable_stoptimestamp();
  // @@protoc_insertion_point(field_mutable:EventMetadata.stopTimestamp)
  return _msg;
}
inline void EventMetadata::set_allocated_stoptimestamp(::Timestamp* stoptimestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stoptimestamp_;
  }
  if (stoptimestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stoptimestamp);
    if (message_arena != submessage_arena) {
      stoptimestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stoptimestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stoptimestamp_ = stoptimestamp;
  // @@protoc_insertion_point(field_set_allocated:EventMetadata.stopTimestamp)
}

// -------------------------------------------------------------------

// Timestamp

// uint64 epochSeconds = 1;
inline void Timestamp::clear_epochseconds() {
  _impl_.epochseconds_ = uint64_t{0u};
}
inline uint64_t Timestamp::_internal_epochseconds() const {
  return _impl_.epochseconds_;
}
inline uint64_t Timestamp::epochseconds() const {
  // @@protoc_insertion_point(field_get:Timestamp.epochSeconds)
  return _internal_epochseconds();
}
inline void Timestamp::_internal_set_epochseconds(uint64_t value) {
  
  _impl_.epochseconds_ = value;
}
inline void Timestamp::set_epochseconds(uint64_t value) {
  _internal_set_epochseconds(value);
  // @@protoc_insertion_point(field_set:Timestamp.epochSeconds)
}

// uint64 nanoseconds = 2;
inline void Timestamp::clear_nanoseconds() {
  _impl_.nanoseconds_ = uint64_t{0u};
}
inline uint64_t Timestamp::_internal_nanoseconds() const {
  return _impl_.nanoseconds_;
}
inline uint64_t Timestamp::nanoseconds() const {
  // @@protoc_insertion_point(field_get:Timestamp.nanoseconds)
  return _internal_nanoseconds();
}
inline void Timestamp::_internal_set_nanoseconds(uint64_t value) {
  
  _impl_.nanoseconds_ = value;
}
inline void Timestamp::set_nanoseconds(uint64_t value) {
  _internal_set_nanoseconds(value);
  // @@protoc_insertion_point(field_set:Timestamp.nanoseconds)
}

// -------------------------------------------------------------------

// TimestampList

// repeated .Timestamp timestamps = 1;
inline int TimestampList::_internal_timestamps_size() const {
  return _impl_.timestamps_.size();
}
inline int TimestampList::timestamps_size() const {
  return _internal_timestamps_size();
}
inline void TimestampList::clear_timestamps() {
  _impl_.timestamps_.Clear();
}
inline ::Timestamp* TimestampList::mutable_timestamps(int index) {
  // @@protoc_insertion_point(field_mutable:TimestampList.timestamps)
  return _impl_.timestamps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Timestamp >*
TimestampList::mutable_timestamps() {
  // @@protoc_insertion_point(field_mutable_list:TimestampList.timestamps)
  return &_impl_.timestamps_;
}
inline const ::Timestamp& TimestampList::_internal_timestamps(int index) const {
  return _impl_.timestamps_.Get(index);
}
inline const ::Timestamp& TimestampList::timestamps(int index) const {
  // @@protoc_insertion_point(field_get:TimestampList.timestamps)
  return _internal_timestamps(index);
}
inline ::Timestamp* TimestampList::_internal_add_timestamps() {
  return _impl_.timestamps_.Add();
}
inline ::Timestamp* TimestampList::add_timestamps() {
  ::Timestamp* _add = _internal_add_timestamps();
  // @@protoc_insertion_point(field_add:TimestampList.timestamps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Timestamp >&
TimestampList::timestamps() const {
  // @@protoc_insertion_point(field_list:TimestampList.timestamps)
  return _impl_.timestamps_;
}

// -------------------------------------------------------------------

// SamplingClock

// .Timestamp startTime = 1;
inline bool SamplingClock::_internal_has_starttime() const {
  return this != internal_default_instance() && _impl_.starttime_ != nullptr;
}
inline bool SamplingClock::has_starttime() const {
  return _internal_has_starttime();
}
inline void SamplingClock::clear_starttime() {
  if (GetArenaForAllocation() == nullptr && _impl_.starttime_ != nullptr) {
    delete _impl_.starttime_;
  }
  _impl_.starttime_ = nullptr;
}
inline const ::Timestamp& SamplingClock::_internal_starttime() const {
  const ::Timestamp* p = _impl_.starttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::Timestamp&>(
      ::_Timestamp_default_instance_);
}
inline const ::Timestamp& SamplingClock::starttime() const {
  // @@protoc_insertion_point(field_get:SamplingClock.startTime)
  return _internal_starttime();
}
inline void SamplingClock::unsafe_arena_set_allocated_starttime(
    ::Timestamp* starttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.starttime_);
  }
  _impl_.starttime_ = starttime;
  if (starttime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SamplingClock.startTime)
}
inline ::Timestamp* SamplingClock::release_starttime() {
  
  ::Timestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Timestamp* SamplingClock::unsafe_arena_release_starttime() {
  // @@protoc_insertion_point(field_release:SamplingClock.startTime)
  
  ::Timestamp* temp = _impl_.starttime_;
  _impl_.starttime_ = nullptr;
  return temp;
}
inline ::Timestamp* SamplingClock::_internal_mutable_starttime() {
  
  if (_impl_.starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::Timestamp>(GetArenaForAllocation());
    _impl_.starttime_ = p;
  }
  return _impl_.starttime_;
}
inline ::Timestamp* SamplingClock::mutable_starttime() {
  ::Timestamp* _msg = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:SamplingClock.startTime)
  return _msg;
}
inline void SamplingClock::set_allocated_starttime(::Timestamp* starttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.starttime_;
  }
  if (starttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(starttime);
    if (message_arena != submessage_arena) {
      starttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:SamplingClock.startTime)
}

// uint64 periodNanos = 2;
inline void SamplingClock::clear_periodnanos() {
  _impl_.periodnanos_ = uint64_t{0u};
}
inline uint64_t SamplingClock::_internal_periodnanos() const {
  return _impl_.periodnanos_;
}
inline uint64_t SamplingClock::periodnanos() const {
  // @@protoc_insertion_point(field_get:SamplingClock.periodNanos)
  return _internal_periodnanos();
}
inline void SamplingClock::_internal_set_periodnanos(uint64_t value) {
  
  _impl_.periodnanos_ = value;
}
inline void SamplingClock::set_periodnanos(uint64_t value) {
  _internal_set_periodnanos(value);
  // @@protoc_insertion_point(field_set:SamplingClock.periodNanos)
}

// uint32 count = 3;
inline void SamplingClock::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t SamplingClock::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t SamplingClock::count() const {
  // @@protoc_insertion_point(field_get:SamplingClock.count)
  return _internal_count();
}
inline void SamplingClock::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void SamplingClock::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SamplingClock.count)
}

// -------------------------------------------------------------------

// DataTimestamps

// .SamplingClock samplingClock = 1;
inline bool DataTimestamps::_internal_has_samplingclock() const {
  return value_case() == kSamplingClock;
}
inline bool DataTimestamps::has_samplingclock() const {
  return _internal_has_samplingclock();
}
inline void DataTimestamps::set_has_samplingclock() {
  _impl_._oneof_case_[0] = kSamplingClock;
}
inline void DataTimestamps::clear_samplingclock() {
  if (_internal_has_samplingclock()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.samplingclock_;
    }
    clear_has_value();
  }
}
inline ::SamplingClock* DataTimestamps::release_samplingclock() {
  // @@protoc_insertion_point(field_release:DataTimestamps.samplingClock)
  if (_internal_has_samplingclock()) {
    clear_has_value();
    ::SamplingClock* temp = _impl_.value_.samplingclock_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.samplingclock_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SamplingClock& DataTimestamps::_internal_samplingclock() const {
  return _internal_has_samplingclock()
      ? *_impl_.value_.samplingclock_
      : reinterpret_cast< ::SamplingClock&>(::_SamplingClock_default_instance_);
}
inline const ::SamplingClock& DataTimestamps::samplingclock() const {
  // @@protoc_insertion_point(field_get:DataTimestamps.samplingClock)
  return _internal_samplingclock();
}
inline ::SamplingClock* DataTimestamps::unsafe_arena_release_samplingclock() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DataTimestamps.samplingClock)
  if (_internal_has_samplingclock()) {
    clear_has_value();
    ::SamplingClock* temp = _impl_.value_.samplingclock_;
    _impl_.value_.samplingclock_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataTimestamps::unsafe_arena_set_allocated_samplingclock(::SamplingClock* samplingclock) {
  clear_value();
  if (samplingclock) {
    set_has_samplingclock();
    _impl_.value_.samplingclock_ = samplingclock;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataTimestamps.samplingClock)
}
inline ::SamplingClock* DataTimestamps::_internal_mutable_samplingclock() {
  if (!_internal_has_samplingclock()) {
    clear_value();
    set_has_samplingclock();
    _impl_.value_.samplingclock_ = CreateMaybeMessage< ::SamplingClock >(GetArenaForAllocation());
  }
  return _impl_.value_.samplingclock_;
}
inline ::SamplingClock* DataTimestamps::mutable_samplingclock() {
  ::SamplingClock* _msg = _internal_mutable_samplingclock();
  // @@protoc_insertion_point(field_mutable:DataTimestamps.samplingClock)
  return _msg;
}

// .TimestampList timestampList = 2;
inline bool DataTimestamps::_internal_has_timestamplist() const {
  return value_case() == kTimestampList;
}
inline bool DataTimestamps::has_timestamplist() const {
  return _internal_has_timestamplist();
}
inline void DataTimestamps::set_has_timestamplist() {
  _impl_._oneof_case_[0] = kTimestampList;
}
inline void DataTimestamps::clear_timestamplist() {
  if (_internal_has_timestamplist()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.timestamplist_;
    }
    clear_has_value();
  }
}
inline ::TimestampList* DataTimestamps::release_timestamplist() {
  // @@protoc_insertion_point(field_release:DataTimestamps.timestampList)
  if (_internal_has_timestamplist()) {
    clear_has_value();
    ::TimestampList* temp = _impl_.value_.timestamplist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.timestamplist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TimestampList& DataTimestamps::_internal_timestamplist() const {
  return _internal_has_timestamplist()
      ? *_impl_.value_.timestamplist_
      : reinterpret_cast< ::TimestampList&>(::_TimestampList_default_instance_);
}
inline const ::TimestampList& DataTimestamps::timestamplist() const {
  // @@protoc_insertion_point(field_get:DataTimestamps.timestampList)
  return _internal_timestamplist();
}
inline ::TimestampList* DataTimestamps::unsafe_arena_release_timestamplist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DataTimestamps.timestampList)
  if (_internal_has_timestamplist()) {
    clear_has_value();
    ::TimestampList* temp = _impl_.value_.timestamplist_;
    _impl_.value_.timestamplist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataTimestamps::unsafe_arena_set_allocated_timestamplist(::TimestampList* timestamplist) {
  clear_value();
  if (timestamplist) {
    set_has_timestamplist();
    _impl_.value_.timestamplist_ = timestamplist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataTimestamps.timestampList)
}
inline ::TimestampList* DataTimestamps::_internal_mutable_timestamplist() {
  if (!_internal_has_timestamplist()) {
    clear_value();
    set_has_timestamplist();
    _impl_.value_.timestamplist_ = CreateMaybeMessage< ::TimestampList >(GetArenaForAllocation());
  }
  return _impl_.value_.timestamplist_;
}
inline ::TimestampList* DataTimestamps::mutable_timestamplist() {
  ::TimestampList* _msg = _internal_mutable_timestamplist();
  // @@protoc_insertion_point(field_mutable:DataTimestamps.timestampList)
  return _msg;
}

inline bool DataTimestamps::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void DataTimestamps::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline DataTimestamps::ValueCase DataTimestamps::value_case() const {
  return DataTimestamps::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExceptionalResult

// .ExceptionalResult.ExceptionalResultStatus exceptionalResultStatus = 1;
inline void ExceptionalResult::clear_exceptionalresultstatus() {
  _impl_.exceptionalresultstatus_ = 0;
}
inline ::ExceptionalResult_ExceptionalResultStatus ExceptionalResult::_internal_exceptionalresultstatus() const {
  return static_cast< ::ExceptionalResult_ExceptionalResultStatus >(_impl_.exceptionalresultstatus_);
}
inline ::ExceptionalResult_ExceptionalResultStatus ExceptionalResult::exceptionalresultstatus() const {
  // @@protoc_insertion_point(field_get:ExceptionalResult.exceptionalResultStatus)
  return _internal_exceptionalresultstatus();
}
inline void ExceptionalResult::_internal_set_exceptionalresultstatus(::ExceptionalResult_ExceptionalResultStatus value) {
  
  _impl_.exceptionalresultstatus_ = value;
}
inline void ExceptionalResult::set_exceptionalresultstatus(::ExceptionalResult_ExceptionalResultStatus value) {
  _internal_set_exceptionalresultstatus(value);
  // @@protoc_insertion_point(field_set:ExceptionalResult.exceptionalResultStatus)
}

// string message = 2;
inline void ExceptionalResult::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ExceptionalResult::message() const {
  // @@protoc_insertion_point(field_get:ExceptionalResult.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExceptionalResult::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ExceptionalResult.message)
}
inline std::string* ExceptionalResult::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ExceptionalResult.message)
  return _s;
}
inline const std::string& ExceptionalResult::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ExceptionalResult::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ExceptionalResult::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ExceptionalResult::release_message() {
  // @@protoc_insertion_point(field_release:ExceptionalResult.message)
  return _impl_.message_.Release();
}
inline void ExceptionalResult::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ExceptionalResult.message)
}

// -------------------------------------------------------------------

// DataColumn

// string name = 1;
inline void DataColumn::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DataColumn::name() const {
  // @@protoc_insertion_point(field_get:DataColumn.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataColumn::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DataColumn.name)
}
inline std::string* DataColumn::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:DataColumn.name)
  return _s;
}
inline const std::string& DataColumn::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DataColumn::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataColumn::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataColumn::release_name() {
  // @@protoc_insertion_point(field_release:DataColumn.name)
  return _impl_.name_.Release();
}
inline void DataColumn::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DataColumn.name)
}

// repeated .DataValue dataValues = 2;
inline int DataColumn::_internal_datavalues_size() const {
  return _impl_.datavalues_.size();
}
inline int DataColumn::datavalues_size() const {
  return _internal_datavalues_size();
}
inline void DataColumn::clear_datavalues() {
  _impl_.datavalues_.Clear();
}
inline ::DataValue* DataColumn::mutable_datavalues(int index) {
  // @@protoc_insertion_point(field_mutable:DataColumn.dataValues)
  return _impl_.datavalues_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataValue >*
DataColumn::mutable_datavalues() {
  // @@protoc_insertion_point(field_mutable_list:DataColumn.dataValues)
  return &_impl_.datavalues_;
}
inline const ::DataValue& DataColumn::_internal_datavalues(int index) const {
  return _impl_.datavalues_.Get(index);
}
inline const ::DataValue& DataColumn::datavalues(int index) const {
  // @@protoc_insertion_point(field_get:DataColumn.dataValues)
  return _internal_datavalues(index);
}
inline ::DataValue* DataColumn::_internal_add_datavalues() {
  return _impl_.datavalues_.Add();
}
inline ::DataValue* DataColumn::add_datavalues() {
  ::DataValue* _add = _internal_add_datavalues();
  // @@protoc_insertion_point(field_add:DataColumn.dataValues)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataValue >&
DataColumn::datavalues() const {
  // @@protoc_insertion_point(field_list:DataColumn.dataValues)
  return _impl_.datavalues_;
}

// -------------------------------------------------------------------

// DataValue_ValueStatus

// string message = 1;
inline void DataValue_ValueStatus::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& DataValue_ValueStatus::message() const {
  // @@protoc_insertion_point(field_get:DataValue.ValueStatus.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataValue_ValueStatus::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DataValue.ValueStatus.message)
}
inline std::string* DataValue_ValueStatus::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:DataValue.ValueStatus.message)
  return _s;
}
inline const std::string& DataValue_ValueStatus::_internal_message() const {
  return _impl_.message_.Get();
}
inline void DataValue_ValueStatus::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* DataValue_ValueStatus::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* DataValue_ValueStatus::release_message() {
  // @@protoc_insertion_point(field_release:DataValue.ValueStatus.message)
  return _impl_.message_.Release();
}
inline void DataValue_ValueStatus::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DataValue.ValueStatus.message)
}

// .DataValue.ValueStatus.StatusCode statusCode = 2;
inline void DataValue_ValueStatus::clear_statuscode() {
  _impl_.statuscode_ = 0;
}
inline ::DataValue_ValueStatus_StatusCode DataValue_ValueStatus::_internal_statuscode() const {
  return static_cast< ::DataValue_ValueStatus_StatusCode >(_impl_.statuscode_);
}
inline ::DataValue_ValueStatus_StatusCode DataValue_ValueStatus::statuscode() const {
  // @@protoc_insertion_point(field_get:DataValue.ValueStatus.statusCode)
  return _internal_statuscode();
}
inline void DataValue_ValueStatus::_internal_set_statuscode(::DataValue_ValueStatus_StatusCode value) {
  
  _impl_.statuscode_ = value;
}
inline void DataValue_ValueStatus::set_statuscode(::DataValue_ValueStatus_StatusCode value) {
  _internal_set_statuscode(value);
  // @@protoc_insertion_point(field_set:DataValue.ValueStatus.statusCode)
}

// .DataValue.ValueStatus.Severity severity = 3;
inline void DataValue_ValueStatus::clear_severity() {
  _impl_.severity_ = 0;
}
inline ::DataValue_ValueStatus_Severity DataValue_ValueStatus::_internal_severity() const {
  return static_cast< ::DataValue_ValueStatus_Severity >(_impl_.severity_);
}
inline ::DataValue_ValueStatus_Severity DataValue_ValueStatus::severity() const {
  // @@protoc_insertion_point(field_get:DataValue.ValueStatus.severity)
  return _internal_severity();
}
inline void DataValue_ValueStatus::_internal_set_severity(::DataValue_ValueStatus_Severity value) {
  
  _impl_.severity_ = value;
}
inline void DataValue_ValueStatus::set_severity(::DataValue_ValueStatus_Severity value) {
  _internal_set_severity(value);
  // @@protoc_insertion_point(field_set:DataValue.ValueStatus.severity)
}

// -------------------------------------------------------------------

// DataValue

// string stringValue = 1;
inline bool DataValue::_internal_has_stringvalue() const {
  return value_case() == kStringValue;
}
inline bool DataValue::has_stringvalue() const {
  return _internal_has_stringvalue();
}
inline void DataValue::set_has_stringvalue() {
  _impl_._oneof_case_[0] = kStringValue;
}
inline void DataValue::clear_stringvalue() {
  if (_internal_has_stringvalue()) {
    _impl_.value_.stringvalue_.Destroy();
    clear_has_value();
  }
}
inline const std::string& DataValue::stringvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.stringValue)
  return _internal_stringvalue();
}
template <typename ArgT0, typename... ArgT>
inline void DataValue::set_stringvalue(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_stringvalue()) {
    clear_value();
    set_has_stringvalue();
    _impl_.value_.stringvalue_.InitDefault();
  }
  _impl_.value_.stringvalue_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DataValue.stringValue)
}
inline std::string* DataValue::mutable_stringvalue() {
  std::string* _s = _internal_mutable_stringvalue();
  // @@protoc_insertion_point(field_mutable:DataValue.stringValue)
  return _s;
}
inline const std::string& DataValue::_internal_stringvalue() const {
  if (_internal_has_stringvalue()) {
    return _impl_.value_.stringvalue_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataValue::_internal_set_stringvalue(const std::string& value) {
  if (!_internal_has_stringvalue()) {
    clear_value();
    set_has_stringvalue();
    _impl_.value_.stringvalue_.InitDefault();
  }
  _impl_.value_.stringvalue_.Set(value, GetArenaForAllocation());
}
inline std::string* DataValue::_internal_mutable_stringvalue() {
  if (!_internal_has_stringvalue()) {
    clear_value();
    set_has_stringvalue();
    _impl_.value_.stringvalue_.InitDefault();
  }
  return _impl_.value_.stringvalue_.Mutable(      GetArenaForAllocation());
}
inline std::string* DataValue::release_stringvalue() {
  // @@protoc_insertion_point(field_release:DataValue.stringValue)
  if (_internal_has_stringvalue()) {
    clear_has_value();
    return _impl_.value_.stringvalue_.Release();
  } else {
    return nullptr;
  }
}
inline void DataValue::set_allocated_stringvalue(std::string* stringvalue) {
  if (has_value()) {
    clear_value();
  }
  if (stringvalue != nullptr) {
    set_has_stringvalue();
    _impl_.value_.stringvalue_.InitAllocated(stringvalue, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:DataValue.stringValue)
}

// bool booleanValue = 2;
inline bool DataValue::_internal_has_booleanvalue() const {
  return value_case() == kBooleanValue;
}
inline bool DataValue::has_booleanvalue() const {
  return _internal_has_booleanvalue();
}
inline void DataValue::set_has_booleanvalue() {
  _impl_._oneof_case_[0] = kBooleanValue;
}
inline void DataValue::clear_booleanvalue() {
  if (_internal_has_booleanvalue()) {
    _impl_.value_.booleanvalue_ = false;
    clear_has_value();
  }
}
inline bool DataValue::_internal_booleanvalue() const {
  if (_internal_has_booleanvalue()) {
    return _impl_.value_.booleanvalue_;
  }
  return false;
}
inline void DataValue::_internal_set_booleanvalue(bool value) {
  if (!_internal_has_booleanvalue()) {
    clear_value();
    set_has_booleanvalue();
  }
  _impl_.value_.booleanvalue_ = value;
}
inline bool DataValue::booleanvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.booleanValue)
  return _internal_booleanvalue();
}
inline void DataValue::set_booleanvalue(bool value) {
  _internal_set_booleanvalue(value);
  // @@protoc_insertion_point(field_set:DataValue.booleanValue)
}

// uint32 uintValue = 3;
inline bool DataValue::_internal_has_uintvalue() const {
  return value_case() == kUintValue;
}
inline bool DataValue::has_uintvalue() const {
  return _internal_has_uintvalue();
}
inline void DataValue::set_has_uintvalue() {
  _impl_._oneof_case_[0] = kUintValue;
}
inline void DataValue::clear_uintvalue() {
  if (_internal_has_uintvalue()) {
    _impl_.value_.uintvalue_ = 0u;
    clear_has_value();
  }
}
inline uint32_t DataValue::_internal_uintvalue() const {
  if (_internal_has_uintvalue()) {
    return _impl_.value_.uintvalue_;
  }
  return 0u;
}
inline void DataValue::_internal_set_uintvalue(uint32_t value) {
  if (!_internal_has_uintvalue()) {
    clear_value();
    set_has_uintvalue();
  }
  _impl_.value_.uintvalue_ = value;
}
inline uint32_t DataValue::uintvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.uintValue)
  return _internal_uintvalue();
}
inline void DataValue::set_uintvalue(uint32_t value) {
  _internal_set_uintvalue(value);
  // @@protoc_insertion_point(field_set:DataValue.uintValue)
}

// uint64 ulongValue = 4;
inline bool DataValue::_internal_has_ulongvalue() const {
  return value_case() == kUlongValue;
}
inline bool DataValue::has_ulongvalue() const {
  return _internal_has_ulongvalue();
}
inline void DataValue::set_has_ulongvalue() {
  _impl_._oneof_case_[0] = kUlongValue;
}
inline void DataValue::clear_ulongvalue() {
  if (_internal_has_ulongvalue()) {
    _impl_.value_.ulongvalue_ = uint64_t{0u};
    clear_has_value();
  }
}
inline uint64_t DataValue::_internal_ulongvalue() const {
  if (_internal_has_ulongvalue()) {
    return _impl_.value_.ulongvalue_;
  }
  return uint64_t{0u};
}
inline void DataValue::_internal_set_ulongvalue(uint64_t value) {
  if (!_internal_has_ulongvalue()) {
    clear_value();
    set_has_ulongvalue();
  }
  _impl_.value_.ulongvalue_ = value;
}
inline uint64_t DataValue::ulongvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.ulongValue)
  return _internal_ulongvalue();
}
inline void DataValue::set_ulongvalue(uint64_t value) {
  _internal_set_ulongvalue(value);
  // @@protoc_insertion_point(field_set:DataValue.ulongValue)
}

// sint32 intValue = 5;
inline bool DataValue::_internal_has_intvalue() const {
  return value_case() == kIntValue;
}
inline bool DataValue::has_intvalue() const {
  return _internal_has_intvalue();
}
inline void DataValue::set_has_intvalue() {
  _impl_._oneof_case_[0] = kIntValue;
}
inline void DataValue::clear_intvalue() {
  if (_internal_has_intvalue()) {
    _impl_.value_.intvalue_ = 0;
    clear_has_value();
  }
}
inline int32_t DataValue::_internal_intvalue() const {
  if (_internal_has_intvalue()) {
    return _impl_.value_.intvalue_;
  }
  return 0;
}
inline void DataValue::_internal_set_intvalue(int32_t value) {
  if (!_internal_has_intvalue()) {
    clear_value();
    set_has_intvalue();
  }
  _impl_.value_.intvalue_ = value;
}
inline int32_t DataValue::intvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.intValue)
  return _internal_intvalue();
}
inline void DataValue::set_intvalue(int32_t value) {
  _internal_set_intvalue(value);
  // @@protoc_insertion_point(field_set:DataValue.intValue)
}

// sint64 longValue = 6;
inline bool DataValue::_internal_has_longvalue() const {
  return value_case() == kLongValue;
}
inline bool DataValue::has_longvalue() const {
  return _internal_has_longvalue();
}
inline void DataValue::set_has_longvalue() {
  _impl_._oneof_case_[0] = kLongValue;
}
inline void DataValue::clear_longvalue() {
  if (_internal_has_longvalue()) {
    _impl_.value_.longvalue_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t DataValue::_internal_longvalue() const {
  if (_internal_has_longvalue()) {
    return _impl_.value_.longvalue_;
  }
  return int64_t{0};
}
inline void DataValue::_internal_set_longvalue(int64_t value) {
  if (!_internal_has_longvalue()) {
    clear_value();
    set_has_longvalue();
  }
  _impl_.value_.longvalue_ = value;
}
inline int64_t DataValue::longvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.longValue)
  return _internal_longvalue();
}
inline void DataValue::set_longvalue(int64_t value) {
  _internal_set_longvalue(value);
  // @@protoc_insertion_point(field_set:DataValue.longValue)
}

// float floatValue = 7;
inline bool DataValue::_internal_has_floatvalue() const {
  return value_case() == kFloatValue;
}
inline bool DataValue::has_floatvalue() const {
  return _internal_has_floatvalue();
}
inline void DataValue::set_has_floatvalue() {
  _impl_._oneof_case_[0] = kFloatValue;
}
inline void DataValue::clear_floatvalue() {
  if (_internal_has_floatvalue()) {
    _impl_.value_.floatvalue_ = 0;
    clear_has_value();
  }
}
inline float DataValue::_internal_floatvalue() const {
  if (_internal_has_floatvalue()) {
    return _impl_.value_.floatvalue_;
  }
  return 0;
}
inline void DataValue::_internal_set_floatvalue(float value) {
  if (!_internal_has_floatvalue()) {
    clear_value();
    set_has_floatvalue();
  }
  _impl_.value_.floatvalue_ = value;
}
inline float DataValue::floatvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.floatValue)
  return _internal_floatvalue();
}
inline void DataValue::set_floatvalue(float value) {
  _internal_set_floatvalue(value);
  // @@protoc_insertion_point(field_set:DataValue.floatValue)
}

// double doubleValue = 8;
inline bool DataValue::_internal_has_doublevalue() const {
  return value_case() == kDoubleValue;
}
inline bool DataValue::has_doublevalue() const {
  return _internal_has_doublevalue();
}
inline void DataValue::set_has_doublevalue() {
  _impl_._oneof_case_[0] = kDoubleValue;
}
inline void DataValue::clear_doublevalue() {
  if (_internal_has_doublevalue()) {
    _impl_.value_.doublevalue_ = 0;
    clear_has_value();
  }
}
inline double DataValue::_internal_doublevalue() const {
  if (_internal_has_doublevalue()) {
    return _impl_.value_.doublevalue_;
  }
  return 0;
}
inline void DataValue::_internal_set_doublevalue(double value) {
  if (!_internal_has_doublevalue()) {
    clear_value();
    set_has_doublevalue();
  }
  _impl_.value_.doublevalue_ = value;
}
inline double DataValue::doublevalue() const {
  // @@protoc_insertion_point(field_get:DataValue.doubleValue)
  return _internal_doublevalue();
}
inline void DataValue::set_doublevalue(double value) {
  _internal_set_doublevalue(value);
  // @@protoc_insertion_point(field_set:DataValue.doubleValue)
}

// bytes byteArrayValue = 9;
inline bool DataValue::_internal_has_bytearrayvalue() const {
  return value_case() == kByteArrayValue;
}
inline bool DataValue::has_bytearrayvalue() const {
  return _internal_has_bytearrayvalue();
}
inline void DataValue::set_has_bytearrayvalue() {
  _impl_._oneof_case_[0] = kByteArrayValue;
}
inline void DataValue::clear_bytearrayvalue() {
  if (_internal_has_bytearrayvalue()) {
    _impl_.value_.bytearrayvalue_.Destroy();
    clear_has_value();
  }
}
inline const std::string& DataValue::bytearrayvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.byteArrayValue)
  return _internal_bytearrayvalue();
}
template <typename ArgT0, typename... ArgT>
inline void DataValue::set_bytearrayvalue(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_bytearrayvalue()) {
    clear_value();
    set_has_bytearrayvalue();
    _impl_.value_.bytearrayvalue_.InitDefault();
  }
  _impl_.value_.bytearrayvalue_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DataValue.byteArrayValue)
}
inline std::string* DataValue::mutable_bytearrayvalue() {
  std::string* _s = _internal_mutable_bytearrayvalue();
  // @@protoc_insertion_point(field_mutable:DataValue.byteArrayValue)
  return _s;
}
inline const std::string& DataValue::_internal_bytearrayvalue() const {
  if (_internal_has_bytearrayvalue()) {
    return _impl_.value_.bytearrayvalue_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataValue::_internal_set_bytearrayvalue(const std::string& value) {
  if (!_internal_has_bytearrayvalue()) {
    clear_value();
    set_has_bytearrayvalue();
    _impl_.value_.bytearrayvalue_.InitDefault();
  }
  _impl_.value_.bytearrayvalue_.Set(value, GetArenaForAllocation());
}
inline std::string* DataValue::_internal_mutable_bytearrayvalue() {
  if (!_internal_has_bytearrayvalue()) {
    clear_value();
    set_has_bytearrayvalue();
    _impl_.value_.bytearrayvalue_.InitDefault();
  }
  return _impl_.value_.bytearrayvalue_.Mutable(      GetArenaForAllocation());
}
inline std::string* DataValue::release_bytearrayvalue() {
  // @@protoc_insertion_point(field_release:DataValue.byteArrayValue)
  if (_internal_has_bytearrayvalue()) {
    clear_has_value();
    return _impl_.value_.bytearrayvalue_.Release();
  } else {
    return nullptr;
  }
}
inline void DataValue::set_allocated_bytearrayvalue(std::string* bytearrayvalue) {
  if (has_value()) {
    clear_value();
  }
  if (bytearrayvalue != nullptr) {
    set_has_bytearrayvalue();
    _impl_.value_.bytearrayvalue_.InitAllocated(bytearrayvalue, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:DataValue.byteArrayValue)
}

// .Array arrayValue = 10;
inline bool DataValue::_internal_has_arrayvalue() const {
  return value_case() == kArrayValue;
}
inline bool DataValue::has_arrayvalue() const {
  return _internal_has_arrayvalue();
}
inline void DataValue::set_has_arrayvalue() {
  _impl_._oneof_case_[0] = kArrayValue;
}
inline void DataValue::clear_arrayvalue() {
  if (_internal_has_arrayvalue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.arrayvalue_;
    }
    clear_has_value();
  }
}
inline ::Array* DataValue::release_arrayvalue() {
  // @@protoc_insertion_point(field_release:DataValue.arrayValue)
  if (_internal_has_arrayvalue()) {
    clear_has_value();
    ::Array* temp = _impl_.value_.arrayvalue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.arrayvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Array& DataValue::_internal_arrayvalue() const {
  return _internal_has_arrayvalue()
      ? *_impl_.value_.arrayvalue_
      : reinterpret_cast< ::Array&>(::_Array_default_instance_);
}
inline const ::Array& DataValue::arrayvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.arrayValue)
  return _internal_arrayvalue();
}
inline ::Array* DataValue::unsafe_arena_release_arrayvalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DataValue.arrayValue)
  if (_internal_has_arrayvalue()) {
    clear_has_value();
    ::Array* temp = _impl_.value_.arrayvalue_;
    _impl_.value_.arrayvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataValue::unsafe_arena_set_allocated_arrayvalue(::Array* arrayvalue) {
  clear_value();
  if (arrayvalue) {
    set_has_arrayvalue();
    _impl_.value_.arrayvalue_ = arrayvalue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataValue.arrayValue)
}
inline ::Array* DataValue::_internal_mutable_arrayvalue() {
  if (!_internal_has_arrayvalue()) {
    clear_value();
    set_has_arrayvalue();
    _impl_.value_.arrayvalue_ = CreateMaybeMessage< ::Array >(GetArenaForAllocation());
  }
  return _impl_.value_.arrayvalue_;
}
inline ::Array* DataValue::mutable_arrayvalue() {
  ::Array* _msg = _internal_mutable_arrayvalue();
  // @@protoc_insertion_point(field_mutable:DataValue.arrayValue)
  return _msg;
}

// .Structure structureValue = 11;
inline bool DataValue::_internal_has_structurevalue() const {
  return value_case() == kStructureValue;
}
inline bool DataValue::has_structurevalue() const {
  return _internal_has_structurevalue();
}
inline void DataValue::set_has_structurevalue() {
  _impl_._oneof_case_[0] = kStructureValue;
}
inline void DataValue::clear_structurevalue() {
  if (_internal_has_structurevalue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.structurevalue_;
    }
    clear_has_value();
  }
}
inline ::Structure* DataValue::release_structurevalue() {
  // @@protoc_insertion_point(field_release:DataValue.structureValue)
  if (_internal_has_structurevalue()) {
    clear_has_value();
    ::Structure* temp = _impl_.value_.structurevalue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.structurevalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Structure& DataValue::_internal_structurevalue() const {
  return _internal_has_structurevalue()
      ? *_impl_.value_.structurevalue_
      : reinterpret_cast< ::Structure&>(::_Structure_default_instance_);
}
inline const ::Structure& DataValue::structurevalue() const {
  // @@protoc_insertion_point(field_get:DataValue.structureValue)
  return _internal_structurevalue();
}
inline ::Structure* DataValue::unsafe_arena_release_structurevalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DataValue.structureValue)
  if (_internal_has_structurevalue()) {
    clear_has_value();
    ::Structure* temp = _impl_.value_.structurevalue_;
    _impl_.value_.structurevalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataValue::unsafe_arena_set_allocated_structurevalue(::Structure* structurevalue) {
  clear_value();
  if (structurevalue) {
    set_has_structurevalue();
    _impl_.value_.structurevalue_ = structurevalue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataValue.structureValue)
}
inline ::Structure* DataValue::_internal_mutable_structurevalue() {
  if (!_internal_has_structurevalue()) {
    clear_value();
    set_has_structurevalue();
    _impl_.value_.structurevalue_ = CreateMaybeMessage< ::Structure >(GetArenaForAllocation());
  }
  return _impl_.value_.structurevalue_;
}
inline ::Structure* DataValue::mutable_structurevalue() {
  ::Structure* _msg = _internal_mutable_structurevalue();
  // @@protoc_insertion_point(field_mutable:DataValue.structureValue)
  return _msg;
}

// .Image imageValue = 12;
inline bool DataValue::_internal_has_imagevalue() const {
  return value_case() == kImageValue;
}
inline bool DataValue::has_imagevalue() const {
  return _internal_has_imagevalue();
}
inline void DataValue::set_has_imagevalue() {
  _impl_._oneof_case_[0] = kImageValue;
}
inline void DataValue::clear_imagevalue() {
  if (_internal_has_imagevalue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.imagevalue_;
    }
    clear_has_value();
  }
}
inline ::Image* DataValue::release_imagevalue() {
  // @@protoc_insertion_point(field_release:DataValue.imageValue)
  if (_internal_has_imagevalue()) {
    clear_has_value();
    ::Image* temp = _impl_.value_.imagevalue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.imagevalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Image& DataValue::_internal_imagevalue() const {
  return _internal_has_imagevalue()
      ? *_impl_.value_.imagevalue_
      : reinterpret_cast< ::Image&>(::_Image_default_instance_);
}
inline const ::Image& DataValue::imagevalue() const {
  // @@protoc_insertion_point(field_get:DataValue.imageValue)
  return _internal_imagevalue();
}
inline ::Image* DataValue::unsafe_arena_release_imagevalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DataValue.imageValue)
  if (_internal_has_imagevalue()) {
    clear_has_value();
    ::Image* temp = _impl_.value_.imagevalue_;
    _impl_.value_.imagevalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataValue::unsafe_arena_set_allocated_imagevalue(::Image* imagevalue) {
  clear_value();
  if (imagevalue) {
    set_has_imagevalue();
    _impl_.value_.imagevalue_ = imagevalue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataValue.imageValue)
}
inline ::Image* DataValue::_internal_mutable_imagevalue() {
  if (!_internal_has_imagevalue()) {
    clear_value();
    set_has_imagevalue();
    _impl_.value_.imagevalue_ = CreateMaybeMessage< ::Image >(GetArenaForAllocation());
  }
  return _impl_.value_.imagevalue_;
}
inline ::Image* DataValue::mutable_imagevalue() {
  ::Image* _msg = _internal_mutable_imagevalue();
  // @@protoc_insertion_point(field_mutable:DataValue.imageValue)
  return _msg;
}

// .Timestamp timestampValue = 13;
inline bool DataValue::_internal_has_timestampvalue() const {
  return value_case() == kTimestampValue;
}
inline bool DataValue::has_timestampvalue() const {
  return _internal_has_timestampvalue();
}
inline void DataValue::set_has_timestampvalue() {
  _impl_._oneof_case_[0] = kTimestampValue;
}
inline void DataValue::clear_timestampvalue() {
  if (_internal_has_timestampvalue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.timestampvalue_;
    }
    clear_has_value();
  }
}
inline ::Timestamp* DataValue::release_timestampvalue() {
  // @@protoc_insertion_point(field_release:DataValue.timestampValue)
  if (_internal_has_timestampvalue()) {
    clear_has_value();
    ::Timestamp* temp = _impl_.value_.timestampvalue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.timestampvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Timestamp& DataValue::_internal_timestampvalue() const {
  return _internal_has_timestampvalue()
      ? *_impl_.value_.timestampvalue_
      : reinterpret_cast< ::Timestamp&>(::_Timestamp_default_instance_);
}
inline const ::Timestamp& DataValue::timestampvalue() const {
  // @@protoc_insertion_point(field_get:DataValue.timestampValue)
  return _internal_timestampvalue();
}
inline ::Timestamp* DataValue::unsafe_arena_release_timestampvalue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:DataValue.timestampValue)
  if (_internal_has_timestampvalue()) {
    clear_has_value();
    ::Timestamp* temp = _impl_.value_.timestampvalue_;
    _impl_.value_.timestampvalue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataValue::unsafe_arena_set_allocated_timestampvalue(::Timestamp* timestampvalue) {
  clear_value();
  if (timestampvalue) {
    set_has_timestampvalue();
    _impl_.value_.timestampvalue_ = timestampvalue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataValue.timestampValue)
}
inline ::Timestamp* DataValue::_internal_mutable_timestampvalue() {
  if (!_internal_has_timestampvalue()) {
    clear_value();
    set_has_timestampvalue();
    _impl_.value_.timestampvalue_ = CreateMaybeMessage< ::Timestamp >(GetArenaForAllocation());
  }
  return _impl_.value_.timestampvalue_;
}
inline ::Timestamp* DataValue::mutable_timestampvalue() {
  ::Timestamp* _msg = _internal_mutable_timestampvalue();
  // @@protoc_insertion_point(field_mutable:DataValue.timestampValue)
  return _msg;
}

// .DataValue.ValueStatus valueStatus = 15;
inline bool DataValue::_internal_has_valuestatus() const {
  return this != internal_default_instance() && _impl_.valuestatus_ != nullptr;
}
inline bool DataValue::has_valuestatus() const {
  return _internal_has_valuestatus();
}
inline void DataValue::clear_valuestatus() {
  if (GetArenaForAllocation() == nullptr && _impl_.valuestatus_ != nullptr) {
    delete _impl_.valuestatus_;
  }
  _impl_.valuestatus_ = nullptr;
}
inline const ::DataValue_ValueStatus& DataValue::_internal_valuestatus() const {
  const ::DataValue_ValueStatus* p = _impl_.valuestatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::DataValue_ValueStatus&>(
      ::_DataValue_ValueStatus_default_instance_);
}
inline const ::DataValue_ValueStatus& DataValue::valuestatus() const {
  // @@protoc_insertion_point(field_get:DataValue.valueStatus)
  return _internal_valuestatus();
}
inline void DataValue::unsafe_arena_set_allocated_valuestatus(
    ::DataValue_ValueStatus* valuestatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valuestatus_);
  }
  _impl_.valuestatus_ = valuestatus;
  if (valuestatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DataValue.valueStatus)
}
inline ::DataValue_ValueStatus* DataValue::release_valuestatus() {
  
  ::DataValue_ValueStatus* temp = _impl_.valuestatus_;
  _impl_.valuestatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DataValue_ValueStatus* DataValue::unsafe_arena_release_valuestatus() {
  // @@protoc_insertion_point(field_release:DataValue.valueStatus)
  
  ::DataValue_ValueStatus* temp = _impl_.valuestatus_;
  _impl_.valuestatus_ = nullptr;
  return temp;
}
inline ::DataValue_ValueStatus* DataValue::_internal_mutable_valuestatus() {
  
  if (_impl_.valuestatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::DataValue_ValueStatus>(GetArenaForAllocation());
    _impl_.valuestatus_ = p;
  }
  return _impl_.valuestatus_;
}
inline ::DataValue_ValueStatus* DataValue::mutable_valuestatus() {
  ::DataValue_ValueStatus* _msg = _internal_mutable_valuestatus();
  // @@protoc_insertion_point(field_mutable:DataValue.valueStatus)
  return _msg;
}
inline void DataValue::set_allocated_valuestatus(::DataValue_ValueStatus* valuestatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.valuestatus_;
  }
  if (valuestatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(valuestatus);
    if (message_arena != submessage_arena) {
      valuestatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valuestatus, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.valuestatus_ = valuestatus;
  // @@protoc_insertion_point(field_set_allocated:DataValue.valueStatus)
}

inline bool DataValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void DataValue::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline DataValue::ValueCase DataValue::value_case() const {
  return DataValue::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Structure_Field

// string name = 1;
inline void Structure_Field::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Structure_Field::name() const {
  // @@protoc_insertion_point(field_get:Structure.Field.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Structure_Field::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Structure.Field.name)
}
inline std::string* Structure_Field::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Structure.Field.name)
  return _s;
}
inline const std::string& Structure_Field::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Structure_Field::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Structure_Field::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Structure_Field::release_name() {
  // @@protoc_insertion_point(field_release:Structure.Field.name)
  return _impl_.name_.Release();
}
inline void Structure_Field::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Structure.Field.name)
}

// .DataValue value = 2;
inline bool Structure_Field::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool Structure_Field::has_value() const {
  return _internal_has_value();
}
inline void Structure_Field::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::DataValue& Structure_Field::_internal_value() const {
  const ::DataValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::DataValue&>(
      ::_DataValue_default_instance_);
}
inline const ::DataValue& Structure_Field::value() const {
  // @@protoc_insertion_point(field_get:Structure.Field.value)
  return _internal_value();
}
inline void Structure_Field::unsafe_arena_set_allocated_value(
    ::DataValue* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Structure.Field.value)
}
inline ::DataValue* Structure_Field::release_value() {
  
  ::DataValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DataValue* Structure_Field::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:Structure.Field.value)
  
  ::DataValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::DataValue* Structure_Field::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::DataValue>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::DataValue* Structure_Field::mutable_value() {
  ::DataValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:Structure.Field.value)
  return _msg;
}
inline void Structure_Field::set_allocated_value(::DataValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:Structure.Field.value)
}

// -------------------------------------------------------------------

// Structure

// repeated .Structure.Field fields = 1;
inline int Structure::_internal_fields_size() const {
  return _impl_.fields_.size();
}
inline int Structure::fields_size() const {
  return _internal_fields_size();
}
inline void Structure::clear_fields() {
  _impl_.fields_.Clear();
}
inline ::Structure_Field* Structure::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:Structure.fields)
  return _impl_.fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Structure_Field >*
Structure::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:Structure.fields)
  return &_impl_.fields_;
}
inline const ::Structure_Field& Structure::_internal_fields(int index) const {
  return _impl_.fields_.Get(index);
}
inline const ::Structure_Field& Structure::fields(int index) const {
  // @@protoc_insertion_point(field_get:Structure.fields)
  return _internal_fields(index);
}
inline ::Structure_Field* Structure::_internal_add_fields() {
  return _impl_.fields_.Add();
}
inline ::Structure_Field* Structure::add_fields() {
  ::Structure_Field* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:Structure.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Structure_Field >&
Structure::fields() const {
  // @@protoc_insertion_point(field_list:Structure.fields)
  return _impl_.fields_;
}

// -------------------------------------------------------------------

// Array

// repeated .DataValue dataValues = 1;
inline int Array::_internal_datavalues_size() const {
  return _impl_.datavalues_.size();
}
inline int Array::datavalues_size() const {
  return _internal_datavalues_size();
}
inline void Array::clear_datavalues() {
  _impl_.datavalues_.Clear();
}
inline ::DataValue* Array::mutable_datavalues(int index) {
  // @@protoc_insertion_point(field_mutable:Array.dataValues)
  return _impl_.datavalues_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataValue >*
Array::mutable_datavalues() {
  // @@protoc_insertion_point(field_mutable_list:Array.dataValues)
  return &_impl_.datavalues_;
}
inline const ::DataValue& Array::_internal_datavalues(int index) const {
  return _impl_.datavalues_.Get(index);
}
inline const ::DataValue& Array::datavalues(int index) const {
  // @@protoc_insertion_point(field_get:Array.dataValues)
  return _internal_datavalues(index);
}
inline ::DataValue* Array::_internal_add_datavalues() {
  return _impl_.datavalues_.Add();
}
inline ::DataValue* Array::add_datavalues() {
  ::DataValue* _add = _internal_add_datavalues();
  // @@protoc_insertion_point(field_add:Array.dataValues)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataValue >&
Array::datavalues() const {
  // @@protoc_insertion_point(field_list:Array.dataValues)
  return _impl_.datavalues_;
}

// -------------------------------------------------------------------

// Image

// bytes image = 1;
inline void Image::clear_image() {
  _impl_.image_.ClearToEmpty();
}
inline const std::string& Image::image() const {
  // @@protoc_insertion_point(field_get:Image.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_image(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Image.image)
}
inline std::string* Image::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:Image.image)
  return _s;
}
inline const std::string& Image::_internal_image() const {
  return _impl_.image_.Get();
}
inline void Image::_internal_set_image(const std::string& value) {
  
  _impl_.image_.Set(value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_image() {
  
  return _impl_.image_.Mutable(GetArenaForAllocation());
}
inline std::string* Image::release_image() {
  // @@protoc_insertion_point(field_release:Image.image)
  return _impl_.image_.Release();
}
inline void Image::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  _impl_.image_.SetAllocated(image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_.IsDefault()) {
    _impl_.image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Image.image)
}

// .Image.FileType fileType = 2;
inline void Image::clear_filetype() {
  _impl_.filetype_ = 0;
}
inline ::Image_FileType Image::_internal_filetype() const {
  return static_cast< ::Image_FileType >(_impl_.filetype_);
}
inline ::Image_FileType Image::filetype() const {
  // @@protoc_insertion_point(field_get:Image.fileType)
  return _internal_filetype();
}
inline void Image::_internal_set_filetype(::Image_FileType value) {
  
  _impl_.filetype_ = value;
}
inline void Image::set_filetype(::Image_FileType value) {
  _internal_set_filetype(value);
  // @@protoc_insertion_point(field_set:Image.fileType)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ExceptionalResult_ExceptionalResultStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ExceptionalResult_ExceptionalResultStatus>() {
  return ::ExceptionalResult_ExceptionalResultStatus_descriptor();
}
template <> struct is_proto_enum< ::DataValue_ValueStatus_StatusCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataValue_ValueStatus_StatusCode>() {
  return ::DataValue_ValueStatus_StatusCode_descriptor();
}
template <> struct is_proto_enum< ::DataValue_ValueStatus_Severity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataValue_ValueStatus_Severity>() {
  return ::DataValue_ValueStatus_Severity_descriptor();
}
template <> struct is_proto_enum< ::Image_FileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Image_FileType>() {
  return ::Image_FileType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2eproto
