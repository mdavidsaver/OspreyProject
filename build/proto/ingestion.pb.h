// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ingestion.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ingestion_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ingestion_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ingestion_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ingestion_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ingestion_2eproto;
namespace dp {
namespace service {
namespace ingestion {
class IngestDataRequest;
struct IngestDataRequestDefaultTypeInternal;
extern IngestDataRequestDefaultTypeInternal _IngestDataRequest_default_instance_;
class IngestDataRequest_IngestionDataFrame;
struct IngestDataRequest_IngestionDataFrameDefaultTypeInternal;
extern IngestDataRequest_IngestionDataFrameDefaultTypeInternal _IngestDataRequest_IngestionDataFrame_default_instance_;
class IngestDataResponse;
struct IngestDataResponseDefaultTypeInternal;
extern IngestDataResponseDefaultTypeInternal _IngestDataResponse_default_instance_;
class IngestDataResponse_AckResult;
struct IngestDataResponse_AckResultDefaultTypeInternal;
extern IngestDataResponse_AckResultDefaultTypeInternal _IngestDataResponse_AckResult_default_instance_;
class RegisterProviderRequest;
struct RegisterProviderRequestDefaultTypeInternal;
extern RegisterProviderRequestDefaultTypeInternal _RegisterProviderRequest_default_instance_;
class RegisterProviderResponse;
struct RegisterProviderResponseDefaultTypeInternal;
extern RegisterProviderResponseDefaultTypeInternal _RegisterProviderResponse_default_instance_;
class RegisterProviderResponse_RegistrationResult;
struct RegisterProviderResponse_RegistrationResultDefaultTypeInternal;
extern RegisterProviderResponse_RegistrationResultDefaultTypeInternal _RegisterProviderResponse_RegistrationResult_default_instance_;
}  // namespace ingestion
}  // namespace service
}  // namespace dp
PROTOBUF_NAMESPACE_OPEN
template<> ::dp::service::ingestion::IngestDataRequest* Arena::CreateMaybeMessage<::dp::service::ingestion::IngestDataRequest>(Arena*);
template<> ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* Arena::CreateMaybeMessage<::dp::service::ingestion::IngestDataRequest_IngestionDataFrame>(Arena*);
template<> ::dp::service::ingestion::IngestDataResponse* Arena::CreateMaybeMessage<::dp::service::ingestion::IngestDataResponse>(Arena*);
template<> ::dp::service::ingestion::IngestDataResponse_AckResult* Arena::CreateMaybeMessage<::dp::service::ingestion::IngestDataResponse_AckResult>(Arena*);
template<> ::dp::service::ingestion::RegisterProviderRequest* Arena::CreateMaybeMessage<::dp::service::ingestion::RegisterProviderRequest>(Arena*);
template<> ::dp::service::ingestion::RegisterProviderResponse* Arena::CreateMaybeMessage<::dp::service::ingestion::RegisterProviderResponse>(Arena*);
template<> ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* Arena::CreateMaybeMessage<::dp::service::ingestion::RegisterProviderResponse_RegistrationResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace dp {
namespace service {
namespace ingestion {

// ===================================================================

class RegisterProviderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dp.service.ingestion.RegisterProviderRequest) */ {
 public:
  inline RegisterProviderRequest() : RegisterProviderRequest(nullptr) {}
  ~RegisterProviderRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterProviderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterProviderRequest(const RegisterProviderRequest& from);
  RegisterProviderRequest(RegisterProviderRequest&& from) noexcept
    : RegisterProviderRequest() {
    *this = ::std::move(from);
  }

  inline RegisterProviderRequest& operator=(const RegisterProviderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterProviderRequest& operator=(RegisterProviderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterProviderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterProviderRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterProviderRequest*>(
               &_RegisterProviderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RegisterProviderRequest& a, RegisterProviderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterProviderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterProviderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterProviderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterProviderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterProviderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterProviderRequest& from) {
    RegisterProviderRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterProviderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dp.service.ingestion.RegisterProviderRequest";
  }
  protected:
  explicit RegisterProviderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 2,
    kProviderNameFieldNumber = 1,
    kRequestTimeFieldNumber = 3,
  };
  // repeated .Attribute attributes = 2;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  ::Attribute* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Attribute >*
      mutable_attributes();
  private:
  const ::Attribute& _internal_attributes(int index) const;
  ::Attribute* _internal_add_attributes();
  public:
  const ::Attribute& attributes(int index) const;
  ::Attribute* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Attribute >&
      attributes() const;

  // string providerName = 1;
  void clear_providername();
  const std::string& providername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_providername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_providername();
  PROTOBUF_NODISCARD std::string* release_providername();
  void set_allocated_providername(std::string* providername);
  private:
  const std::string& _internal_providername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_providername(const std::string& value);
  std::string* _internal_mutable_providername();
  public:

  // .Timestamp requestTime = 3;
  bool has_requesttime() const;
  private:
  bool _internal_has_requesttime() const;
  public:
  void clear_requesttime();
  const ::Timestamp& requesttime() const;
  PROTOBUF_NODISCARD ::Timestamp* release_requesttime();
  ::Timestamp* mutable_requesttime();
  void set_allocated_requesttime(::Timestamp* requesttime);
  private:
  const ::Timestamp& _internal_requesttime() const;
  ::Timestamp* _internal_mutable_requesttime();
  public:
  void unsafe_arena_set_allocated_requesttime(
      ::Timestamp* requesttime);
  ::Timestamp* unsafe_arena_release_requesttime();

  // @@protoc_insertion_point(class_scope:dp.service.ingestion.RegisterProviderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Attribute > attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr providername_;
    ::Timestamp* requesttime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ingestion_2eproto;
};
// -------------------------------------------------------------------

class RegisterProviderResponse_RegistrationResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dp.service.ingestion.RegisterProviderResponse.RegistrationResult) */ {
 public:
  inline RegisterProviderResponse_RegistrationResult() : RegisterProviderResponse_RegistrationResult(nullptr) {}
  ~RegisterProviderResponse_RegistrationResult() override;
  explicit PROTOBUF_CONSTEXPR RegisterProviderResponse_RegistrationResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterProviderResponse_RegistrationResult(const RegisterProviderResponse_RegistrationResult& from);
  RegisterProviderResponse_RegistrationResult(RegisterProviderResponse_RegistrationResult&& from) noexcept
    : RegisterProviderResponse_RegistrationResult() {
    *this = ::std::move(from);
  }

  inline RegisterProviderResponse_RegistrationResult& operator=(const RegisterProviderResponse_RegistrationResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterProviderResponse_RegistrationResult& operator=(RegisterProviderResponse_RegistrationResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterProviderResponse_RegistrationResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterProviderResponse_RegistrationResult* internal_default_instance() {
    return reinterpret_cast<const RegisterProviderResponse_RegistrationResult*>(
               &_RegisterProviderResponse_RegistrationResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegisterProviderResponse_RegistrationResult& a, RegisterProviderResponse_RegistrationResult& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterProviderResponse_RegistrationResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterProviderResponse_RegistrationResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterProviderResponse_RegistrationResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterProviderResponse_RegistrationResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterProviderResponse_RegistrationResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterProviderResponse_RegistrationResult& from) {
    RegisterProviderResponse_RegistrationResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterProviderResponse_RegistrationResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dp.service.ingestion.RegisterProviderResponse.RegistrationResult";
  }
  protected:
  explicit RegisterProviderResponse_RegistrationResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProviderIdFieldNumber = 1,
  };
  // uint32 providerId = 1;
  void clear_providerid();
  uint32_t providerid() const;
  void set_providerid(uint32_t value);
  private:
  uint32_t _internal_providerid() const;
  void _internal_set_providerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dp.service.ingestion.RegisterProviderResponse.RegistrationResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t providerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ingestion_2eproto;
};
// -------------------------------------------------------------------

class RegisterProviderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dp.service.ingestion.RegisterProviderResponse) */ {
 public:
  inline RegisterProviderResponse() : RegisterProviderResponse(nullptr) {}
  ~RegisterProviderResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterProviderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterProviderResponse(const RegisterProviderResponse& from);
  RegisterProviderResponse(RegisterProviderResponse&& from) noexcept
    : RegisterProviderResponse() {
    *this = ::std::move(from);
  }

  inline RegisterProviderResponse& operator=(const RegisterProviderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterProviderResponse& operator=(RegisterProviderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterProviderResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kExceptionalResult = 10,
    kRegistrationResult = 11,
    RESULT_NOT_SET = 0,
  };

  static inline const RegisterProviderResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterProviderResponse*>(
               &_RegisterProviderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegisterProviderResponse& a, RegisterProviderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterProviderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterProviderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterProviderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterProviderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterProviderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterProviderResponse& from) {
    RegisterProviderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterProviderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dp.service.ingestion.RegisterProviderResponse";
  }
  protected:
  explicit RegisterProviderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RegisterProviderResponse_RegistrationResult RegistrationResult;

  // accessors -------------------------------------------------------

  enum : int {
    kResponseTimeFieldNumber = 1,
    kExceptionalResultFieldNumber = 10,
    kRegistrationResultFieldNumber = 11,
  };
  // .Timestamp responseTime = 1;
  bool has_responsetime() const;
  private:
  bool _internal_has_responsetime() const;
  public:
  void clear_responsetime();
  const ::Timestamp& responsetime() const;
  PROTOBUF_NODISCARD ::Timestamp* release_responsetime();
  ::Timestamp* mutable_responsetime();
  void set_allocated_responsetime(::Timestamp* responsetime);
  private:
  const ::Timestamp& _internal_responsetime() const;
  ::Timestamp* _internal_mutable_responsetime();
  public:
  void unsafe_arena_set_allocated_responsetime(
      ::Timestamp* responsetime);
  ::Timestamp* unsafe_arena_release_responsetime();

  // .ExceptionalResult exceptionalResult = 10;
  bool has_exceptionalresult() const;
  private:
  bool _internal_has_exceptionalresult() const;
  public:
  void clear_exceptionalresult();
  const ::ExceptionalResult& exceptionalresult() const;
  PROTOBUF_NODISCARD ::ExceptionalResult* release_exceptionalresult();
  ::ExceptionalResult* mutable_exceptionalresult();
  void set_allocated_exceptionalresult(::ExceptionalResult* exceptionalresult);
  private:
  const ::ExceptionalResult& _internal_exceptionalresult() const;
  ::ExceptionalResult* _internal_mutable_exceptionalresult();
  public:
  void unsafe_arena_set_allocated_exceptionalresult(
      ::ExceptionalResult* exceptionalresult);
  ::ExceptionalResult* unsafe_arena_release_exceptionalresult();

  // .dp.service.ingestion.RegisterProviderResponse.RegistrationResult registrationResult = 11;
  bool has_registrationresult() const;
  private:
  bool _internal_has_registrationresult() const;
  public:
  void clear_registrationresult();
  const ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult& registrationresult() const;
  PROTOBUF_NODISCARD ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* release_registrationresult();
  ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* mutable_registrationresult();
  void set_allocated_registrationresult(::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* registrationresult);
  private:
  const ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult& _internal_registrationresult() const;
  ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* _internal_mutable_registrationresult();
  public:
  void unsafe_arena_set_allocated_registrationresult(
      ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* registrationresult);
  ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* unsafe_arena_release_registrationresult();

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:dp.service.ingestion.RegisterProviderResponse)
 private:
  class _Internal;
  void set_has_exceptionalresult();
  void set_has_registrationresult();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Timestamp* responsetime_;
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ExceptionalResult* exceptionalresult_;
      ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* registrationresult_;
    } result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ingestion_2eproto;
};
// -------------------------------------------------------------------

class IngestDataRequest_IngestionDataFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dp.service.ingestion.IngestDataRequest.IngestionDataFrame) */ {
 public:
  inline IngestDataRequest_IngestionDataFrame() : IngestDataRequest_IngestionDataFrame(nullptr) {}
  ~IngestDataRequest_IngestionDataFrame() override;
  explicit PROTOBUF_CONSTEXPR IngestDataRequest_IngestionDataFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IngestDataRequest_IngestionDataFrame(const IngestDataRequest_IngestionDataFrame& from);
  IngestDataRequest_IngestionDataFrame(IngestDataRequest_IngestionDataFrame&& from) noexcept
    : IngestDataRequest_IngestionDataFrame() {
    *this = ::std::move(from);
  }

  inline IngestDataRequest_IngestionDataFrame& operator=(const IngestDataRequest_IngestionDataFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngestDataRequest_IngestionDataFrame& operator=(IngestDataRequest_IngestionDataFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngestDataRequest_IngestionDataFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const IngestDataRequest_IngestionDataFrame* internal_default_instance() {
    return reinterpret_cast<const IngestDataRequest_IngestionDataFrame*>(
               &_IngestDataRequest_IngestionDataFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IngestDataRequest_IngestionDataFrame& a, IngestDataRequest_IngestionDataFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(IngestDataRequest_IngestionDataFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngestDataRequest_IngestionDataFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngestDataRequest_IngestionDataFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IngestDataRequest_IngestionDataFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IngestDataRequest_IngestionDataFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IngestDataRequest_IngestionDataFrame& from) {
    IngestDataRequest_IngestionDataFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IngestDataRequest_IngestionDataFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dp.service.ingestion.IngestDataRequest.IngestionDataFrame";
  }
  protected:
  explicit IngestDataRequest_IngestionDataFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataColumnsFieldNumber = 2,
    kDataTimestampsFieldNumber = 1,
  };
  // repeated .DataColumn dataColumns = 2;
  int datacolumns_size() const;
  private:
  int _internal_datacolumns_size() const;
  public:
  void clear_datacolumns();
  ::DataColumn* mutable_datacolumns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataColumn >*
      mutable_datacolumns();
  private:
  const ::DataColumn& _internal_datacolumns(int index) const;
  ::DataColumn* _internal_add_datacolumns();
  public:
  const ::DataColumn& datacolumns(int index) const;
  ::DataColumn* add_datacolumns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataColumn >&
      datacolumns() const;

  // .DataTimestamps dataTimestamps = 1;
  bool has_datatimestamps() const;
  private:
  bool _internal_has_datatimestamps() const;
  public:
  void clear_datatimestamps();
  const ::DataTimestamps& datatimestamps() const;
  PROTOBUF_NODISCARD ::DataTimestamps* release_datatimestamps();
  ::DataTimestamps* mutable_datatimestamps();
  void set_allocated_datatimestamps(::DataTimestamps* datatimestamps);
  private:
  const ::DataTimestamps& _internal_datatimestamps() const;
  ::DataTimestamps* _internal_mutable_datatimestamps();
  public:
  void unsafe_arena_set_allocated_datatimestamps(
      ::DataTimestamps* datatimestamps);
  ::DataTimestamps* unsafe_arena_release_datatimestamps();

  // @@protoc_insertion_point(class_scope:dp.service.ingestion.IngestDataRequest.IngestionDataFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataColumn > datacolumns_;
    ::DataTimestamps* datatimestamps_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ingestion_2eproto;
};
// -------------------------------------------------------------------

class IngestDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dp.service.ingestion.IngestDataRequest) */ {
 public:
  inline IngestDataRequest() : IngestDataRequest(nullptr) {}
  ~IngestDataRequest() override;
  explicit PROTOBUF_CONSTEXPR IngestDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IngestDataRequest(const IngestDataRequest& from);
  IngestDataRequest(IngestDataRequest&& from) noexcept
    : IngestDataRequest() {
    *this = ::std::move(from);
  }

  inline IngestDataRequest& operator=(const IngestDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngestDataRequest& operator=(IngestDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngestDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IngestDataRequest* internal_default_instance() {
    return reinterpret_cast<const IngestDataRequest*>(
               &_IngestDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(IngestDataRequest& a, IngestDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IngestDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngestDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngestDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IngestDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IngestDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IngestDataRequest& from) {
    IngestDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IngestDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dp.service.ingestion.IngestDataRequest";
  }
  protected:
  explicit IngestDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef IngestDataRequest_IngestionDataFrame IngestionDataFrame;

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 4,
    kClientRequestIdFieldNumber = 2,
    kRequestTimeFieldNumber = 3,
    kEventMetadataFieldNumber = 5,
    kIngestionDataFrameFieldNumber = 6,
    kProviderIdFieldNumber = 1,
  };
  // repeated .Attribute attributes = 4;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  ::Attribute* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Attribute >*
      mutable_attributes();
  private:
  const ::Attribute& _internal_attributes(int index) const;
  ::Attribute* _internal_add_attributes();
  public:
  const ::Attribute& attributes(int index) const;
  ::Attribute* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Attribute >&
      attributes() const;

  // string clientRequestId = 2;
  void clear_clientrequestid();
  const std::string& clientrequestid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientrequestid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientrequestid();
  PROTOBUF_NODISCARD std::string* release_clientrequestid();
  void set_allocated_clientrequestid(std::string* clientrequestid);
  private:
  const std::string& _internal_clientrequestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientrequestid(const std::string& value);
  std::string* _internal_mutable_clientrequestid();
  public:

  // .Timestamp requestTime = 3;
  bool has_requesttime() const;
  private:
  bool _internal_has_requesttime() const;
  public:
  void clear_requesttime();
  const ::Timestamp& requesttime() const;
  PROTOBUF_NODISCARD ::Timestamp* release_requesttime();
  ::Timestamp* mutable_requesttime();
  void set_allocated_requesttime(::Timestamp* requesttime);
  private:
  const ::Timestamp& _internal_requesttime() const;
  ::Timestamp* _internal_mutable_requesttime();
  public:
  void unsafe_arena_set_allocated_requesttime(
      ::Timestamp* requesttime);
  ::Timestamp* unsafe_arena_release_requesttime();

  // .EventMetadata eventMetadata = 5;
  bool has_eventmetadata() const;
  private:
  bool _internal_has_eventmetadata() const;
  public:
  void clear_eventmetadata();
  const ::EventMetadata& eventmetadata() const;
  PROTOBUF_NODISCARD ::EventMetadata* release_eventmetadata();
  ::EventMetadata* mutable_eventmetadata();
  void set_allocated_eventmetadata(::EventMetadata* eventmetadata);
  private:
  const ::EventMetadata& _internal_eventmetadata() const;
  ::EventMetadata* _internal_mutable_eventmetadata();
  public:
  void unsafe_arena_set_allocated_eventmetadata(
      ::EventMetadata* eventmetadata);
  ::EventMetadata* unsafe_arena_release_eventmetadata();

  // .dp.service.ingestion.IngestDataRequest.IngestionDataFrame ingestionDataFrame = 6;
  bool has_ingestiondataframe() const;
  private:
  bool _internal_has_ingestiondataframe() const;
  public:
  void clear_ingestiondataframe();
  const ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame& ingestiondataframe() const;
  PROTOBUF_NODISCARD ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* release_ingestiondataframe();
  ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* mutable_ingestiondataframe();
  void set_allocated_ingestiondataframe(::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* ingestiondataframe);
  private:
  const ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame& _internal_ingestiondataframe() const;
  ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* _internal_mutable_ingestiondataframe();
  public:
  void unsafe_arena_set_allocated_ingestiondataframe(
      ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* ingestiondataframe);
  ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* unsafe_arena_release_ingestiondataframe();

  // uint32 providerId = 1;
  void clear_providerid();
  uint32_t providerid() const;
  void set_providerid(uint32_t value);
  private:
  uint32_t _internal_providerid() const;
  void _internal_set_providerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dp.service.ingestion.IngestDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Attribute > attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientrequestid_;
    ::Timestamp* requesttime_;
    ::EventMetadata* eventmetadata_;
    ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* ingestiondataframe_;
    uint32_t providerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ingestion_2eproto;
};
// -------------------------------------------------------------------

class IngestDataResponse_AckResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dp.service.ingestion.IngestDataResponse.AckResult) */ {
 public:
  inline IngestDataResponse_AckResult() : IngestDataResponse_AckResult(nullptr) {}
  ~IngestDataResponse_AckResult() override;
  explicit PROTOBUF_CONSTEXPR IngestDataResponse_AckResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IngestDataResponse_AckResult(const IngestDataResponse_AckResult& from);
  IngestDataResponse_AckResult(IngestDataResponse_AckResult&& from) noexcept
    : IngestDataResponse_AckResult() {
    *this = ::std::move(from);
  }

  inline IngestDataResponse_AckResult& operator=(const IngestDataResponse_AckResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngestDataResponse_AckResult& operator=(IngestDataResponse_AckResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngestDataResponse_AckResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const IngestDataResponse_AckResult* internal_default_instance() {
    return reinterpret_cast<const IngestDataResponse_AckResult*>(
               &_IngestDataResponse_AckResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(IngestDataResponse_AckResult& a, IngestDataResponse_AckResult& b) {
    a.Swap(&b);
  }
  inline void Swap(IngestDataResponse_AckResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngestDataResponse_AckResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngestDataResponse_AckResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IngestDataResponse_AckResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IngestDataResponse_AckResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IngestDataResponse_AckResult& from) {
    IngestDataResponse_AckResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IngestDataResponse_AckResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dp.service.ingestion.IngestDataResponse.AckResult";
  }
  protected:
  explicit IngestDataResponse_AckResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumRowsFieldNumber = 1,
    kNumColumnsFieldNumber = 2,
  };
  // uint32 numRows = 1;
  void clear_numrows();
  uint32_t numrows() const;
  void set_numrows(uint32_t value);
  private:
  uint32_t _internal_numrows() const;
  void _internal_set_numrows(uint32_t value);
  public:

  // uint32 numColumns = 2;
  void clear_numcolumns();
  uint32_t numcolumns() const;
  void set_numcolumns(uint32_t value);
  private:
  uint32_t _internal_numcolumns() const;
  void _internal_set_numcolumns(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dp.service.ingestion.IngestDataResponse.AckResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t numrows_;
    uint32_t numcolumns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ingestion_2eproto;
};
// -------------------------------------------------------------------

class IngestDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dp.service.ingestion.IngestDataResponse) */ {
 public:
  inline IngestDataResponse() : IngestDataResponse(nullptr) {}
  ~IngestDataResponse() override;
  explicit PROTOBUF_CONSTEXPR IngestDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IngestDataResponse(const IngestDataResponse& from);
  IngestDataResponse(IngestDataResponse&& from) noexcept
    : IngestDataResponse() {
    *this = ::std::move(from);
  }

  inline IngestDataResponse& operator=(const IngestDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngestDataResponse& operator=(IngestDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngestDataResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kExceptionalResult = 10,
    kAckResult = 11,
    RESULT_NOT_SET = 0,
  };

  static inline const IngestDataResponse* internal_default_instance() {
    return reinterpret_cast<const IngestDataResponse*>(
               &_IngestDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IngestDataResponse& a, IngestDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IngestDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngestDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngestDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IngestDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IngestDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IngestDataResponse& from) {
    IngestDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IngestDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dp.service.ingestion.IngestDataResponse";
  }
  protected:
  explicit IngestDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef IngestDataResponse_AckResult AckResult;

  // accessors -------------------------------------------------------

  enum : int {
    kClientRequestIdFieldNumber = 2,
    kResponseTimeFieldNumber = 3,
    kProviderIdFieldNumber = 1,
    kExceptionalResultFieldNumber = 10,
    kAckResultFieldNumber = 11,
  };
  // string clientRequestId = 2;
  void clear_clientrequestid();
  const std::string& clientrequestid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientrequestid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientrequestid();
  PROTOBUF_NODISCARD std::string* release_clientrequestid();
  void set_allocated_clientrequestid(std::string* clientrequestid);
  private:
  const std::string& _internal_clientrequestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientrequestid(const std::string& value);
  std::string* _internal_mutable_clientrequestid();
  public:

  // .Timestamp responseTime = 3;
  bool has_responsetime() const;
  private:
  bool _internal_has_responsetime() const;
  public:
  void clear_responsetime();
  const ::Timestamp& responsetime() const;
  PROTOBUF_NODISCARD ::Timestamp* release_responsetime();
  ::Timestamp* mutable_responsetime();
  void set_allocated_responsetime(::Timestamp* responsetime);
  private:
  const ::Timestamp& _internal_responsetime() const;
  ::Timestamp* _internal_mutable_responsetime();
  public:
  void unsafe_arena_set_allocated_responsetime(
      ::Timestamp* responsetime);
  ::Timestamp* unsafe_arena_release_responsetime();

  // uint32 providerId = 1;
  void clear_providerid();
  uint32_t providerid() const;
  void set_providerid(uint32_t value);
  private:
  uint32_t _internal_providerid() const;
  void _internal_set_providerid(uint32_t value);
  public:

  // .ExceptionalResult exceptionalResult = 10;
  bool has_exceptionalresult() const;
  private:
  bool _internal_has_exceptionalresult() const;
  public:
  void clear_exceptionalresult();
  const ::ExceptionalResult& exceptionalresult() const;
  PROTOBUF_NODISCARD ::ExceptionalResult* release_exceptionalresult();
  ::ExceptionalResult* mutable_exceptionalresult();
  void set_allocated_exceptionalresult(::ExceptionalResult* exceptionalresult);
  private:
  const ::ExceptionalResult& _internal_exceptionalresult() const;
  ::ExceptionalResult* _internal_mutable_exceptionalresult();
  public:
  void unsafe_arena_set_allocated_exceptionalresult(
      ::ExceptionalResult* exceptionalresult);
  ::ExceptionalResult* unsafe_arena_release_exceptionalresult();

  // .dp.service.ingestion.IngestDataResponse.AckResult ackResult = 11;
  bool has_ackresult() const;
  private:
  bool _internal_has_ackresult() const;
  public:
  void clear_ackresult();
  const ::dp::service::ingestion::IngestDataResponse_AckResult& ackresult() const;
  PROTOBUF_NODISCARD ::dp::service::ingestion::IngestDataResponse_AckResult* release_ackresult();
  ::dp::service::ingestion::IngestDataResponse_AckResult* mutable_ackresult();
  void set_allocated_ackresult(::dp::service::ingestion::IngestDataResponse_AckResult* ackresult);
  private:
  const ::dp::service::ingestion::IngestDataResponse_AckResult& _internal_ackresult() const;
  ::dp::service::ingestion::IngestDataResponse_AckResult* _internal_mutable_ackresult();
  public:
  void unsafe_arena_set_allocated_ackresult(
      ::dp::service::ingestion::IngestDataResponse_AckResult* ackresult);
  ::dp::service::ingestion::IngestDataResponse_AckResult* unsafe_arena_release_ackresult();

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:dp.service.ingestion.IngestDataResponse)
 private:
  class _Internal;
  void set_has_exceptionalresult();
  void set_has_ackresult();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientrequestid_;
    ::Timestamp* responsetime_;
    uint32_t providerid_;
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ExceptionalResult* exceptionalresult_;
      ::dp::service::ingestion::IngestDataResponse_AckResult* ackresult_;
    } result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ingestion_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RegisterProviderRequest

// string providerName = 1;
inline void RegisterProviderRequest::clear_providername() {
  _impl_.providername_.ClearToEmpty();
}
inline const std::string& RegisterProviderRequest::providername() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.RegisterProviderRequest.providerName)
  return _internal_providername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterProviderRequest::set_providername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.providername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dp.service.ingestion.RegisterProviderRequest.providerName)
}
inline std::string* RegisterProviderRequest::mutable_providername() {
  std::string* _s = _internal_mutable_providername();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.RegisterProviderRequest.providerName)
  return _s;
}
inline const std::string& RegisterProviderRequest::_internal_providername() const {
  return _impl_.providername_.Get();
}
inline void RegisterProviderRequest::_internal_set_providername(const std::string& value) {
  
  _impl_.providername_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterProviderRequest::_internal_mutable_providername() {
  
  return _impl_.providername_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterProviderRequest::release_providername() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.RegisterProviderRequest.providerName)
  return _impl_.providername_.Release();
}
inline void RegisterProviderRequest::set_allocated_providername(std::string* providername) {
  if (providername != nullptr) {
    
  } else {
    
  }
  _impl_.providername_.SetAllocated(providername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.providername_.IsDefault()) {
    _impl_.providername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.RegisterProviderRequest.providerName)
}

// repeated .Attribute attributes = 2;
inline int RegisterProviderRequest::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int RegisterProviderRequest::attributes_size() const {
  return _internal_attributes_size();
}
inline ::Attribute* RegisterProviderRequest::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.RegisterProviderRequest.attributes)
  return _impl_.attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Attribute >*
RegisterProviderRequest::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:dp.service.ingestion.RegisterProviderRequest.attributes)
  return &_impl_.attributes_;
}
inline const ::Attribute& RegisterProviderRequest::_internal_attributes(int index) const {
  return _impl_.attributes_.Get(index);
}
inline const ::Attribute& RegisterProviderRequest::attributes(int index) const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.RegisterProviderRequest.attributes)
  return _internal_attributes(index);
}
inline ::Attribute* RegisterProviderRequest::_internal_add_attributes() {
  return _impl_.attributes_.Add();
}
inline ::Attribute* RegisterProviderRequest::add_attributes() {
  ::Attribute* _add = _internal_add_attributes();
  // @@protoc_insertion_point(field_add:dp.service.ingestion.RegisterProviderRequest.attributes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Attribute >&
RegisterProviderRequest::attributes() const {
  // @@protoc_insertion_point(field_list:dp.service.ingestion.RegisterProviderRequest.attributes)
  return _impl_.attributes_;
}

// .Timestamp requestTime = 3;
inline bool RegisterProviderRequest::_internal_has_requesttime() const {
  return this != internal_default_instance() && _impl_.requesttime_ != nullptr;
}
inline bool RegisterProviderRequest::has_requesttime() const {
  return _internal_has_requesttime();
}
inline const ::Timestamp& RegisterProviderRequest::_internal_requesttime() const {
  const ::Timestamp* p = _impl_.requesttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::Timestamp&>(
      ::_Timestamp_default_instance_);
}
inline const ::Timestamp& RegisterProviderRequest::requesttime() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.RegisterProviderRequest.requestTime)
  return _internal_requesttime();
}
inline void RegisterProviderRequest::unsafe_arena_set_allocated_requesttime(
    ::Timestamp* requesttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requesttime_);
  }
  _impl_.requesttime_ = requesttime;
  if (requesttime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.RegisterProviderRequest.requestTime)
}
inline ::Timestamp* RegisterProviderRequest::release_requesttime() {
  
  ::Timestamp* temp = _impl_.requesttime_;
  _impl_.requesttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Timestamp* RegisterProviderRequest::unsafe_arena_release_requesttime() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.RegisterProviderRequest.requestTime)
  
  ::Timestamp* temp = _impl_.requesttime_;
  _impl_.requesttime_ = nullptr;
  return temp;
}
inline ::Timestamp* RegisterProviderRequest::_internal_mutable_requesttime() {
  
  if (_impl_.requesttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::Timestamp>(GetArenaForAllocation());
    _impl_.requesttime_ = p;
  }
  return _impl_.requesttime_;
}
inline ::Timestamp* RegisterProviderRequest::mutable_requesttime() {
  ::Timestamp* _msg = _internal_mutable_requesttime();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.RegisterProviderRequest.requestTime)
  return _msg;
}
inline void RegisterProviderRequest::set_allocated_requesttime(::Timestamp* requesttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requesttime_);
  }
  if (requesttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(requesttime));
    if (message_arena != submessage_arena) {
      requesttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requesttime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.requesttime_ = requesttime;
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.RegisterProviderRequest.requestTime)
}

// -------------------------------------------------------------------

// RegisterProviderResponse_RegistrationResult

// uint32 providerId = 1;
inline void RegisterProviderResponse_RegistrationResult::clear_providerid() {
  _impl_.providerid_ = 0u;
}
inline uint32_t RegisterProviderResponse_RegistrationResult::_internal_providerid() const {
  return _impl_.providerid_;
}
inline uint32_t RegisterProviderResponse_RegistrationResult::providerid() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.RegisterProviderResponse.RegistrationResult.providerId)
  return _internal_providerid();
}
inline void RegisterProviderResponse_RegistrationResult::_internal_set_providerid(uint32_t value) {
  
  _impl_.providerid_ = value;
}
inline void RegisterProviderResponse_RegistrationResult::set_providerid(uint32_t value) {
  _internal_set_providerid(value);
  // @@protoc_insertion_point(field_set:dp.service.ingestion.RegisterProviderResponse.RegistrationResult.providerId)
}

// -------------------------------------------------------------------

// RegisterProviderResponse

// .Timestamp responseTime = 1;
inline bool RegisterProviderResponse::_internal_has_responsetime() const {
  return this != internal_default_instance() && _impl_.responsetime_ != nullptr;
}
inline bool RegisterProviderResponse::has_responsetime() const {
  return _internal_has_responsetime();
}
inline const ::Timestamp& RegisterProviderResponse::_internal_responsetime() const {
  const ::Timestamp* p = _impl_.responsetime_;
  return p != nullptr ? *p : reinterpret_cast<const ::Timestamp&>(
      ::_Timestamp_default_instance_);
}
inline const ::Timestamp& RegisterProviderResponse::responsetime() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.RegisterProviderResponse.responseTime)
  return _internal_responsetime();
}
inline void RegisterProviderResponse::unsafe_arena_set_allocated_responsetime(
    ::Timestamp* responsetime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.responsetime_);
  }
  _impl_.responsetime_ = responsetime;
  if (responsetime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.RegisterProviderResponse.responseTime)
}
inline ::Timestamp* RegisterProviderResponse::release_responsetime() {
  
  ::Timestamp* temp = _impl_.responsetime_;
  _impl_.responsetime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Timestamp* RegisterProviderResponse::unsafe_arena_release_responsetime() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.RegisterProviderResponse.responseTime)
  
  ::Timestamp* temp = _impl_.responsetime_;
  _impl_.responsetime_ = nullptr;
  return temp;
}
inline ::Timestamp* RegisterProviderResponse::_internal_mutable_responsetime() {
  
  if (_impl_.responsetime_ == nullptr) {
    auto* p = CreateMaybeMessage<::Timestamp>(GetArenaForAllocation());
    _impl_.responsetime_ = p;
  }
  return _impl_.responsetime_;
}
inline ::Timestamp* RegisterProviderResponse::mutable_responsetime() {
  ::Timestamp* _msg = _internal_mutable_responsetime();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.RegisterProviderResponse.responseTime)
  return _msg;
}
inline void RegisterProviderResponse::set_allocated_responsetime(::Timestamp* responsetime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.responsetime_);
  }
  if (responsetime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(responsetime));
    if (message_arena != submessage_arena) {
      responsetime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, responsetime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.responsetime_ = responsetime;
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.RegisterProviderResponse.responseTime)
}

// .ExceptionalResult exceptionalResult = 10;
inline bool RegisterProviderResponse::_internal_has_exceptionalresult() const {
  return result_case() == kExceptionalResult;
}
inline bool RegisterProviderResponse::has_exceptionalresult() const {
  return _internal_has_exceptionalresult();
}
inline void RegisterProviderResponse::set_has_exceptionalresult() {
  _impl_._oneof_case_[0] = kExceptionalResult;
}
inline ::ExceptionalResult* RegisterProviderResponse::release_exceptionalresult() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.RegisterProviderResponse.exceptionalResult)
  if (_internal_has_exceptionalresult()) {
    clear_has_result();
    ::ExceptionalResult* temp = _impl_.result_.exceptionalresult_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.exceptionalresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ExceptionalResult& RegisterProviderResponse::_internal_exceptionalresult() const {
  return _internal_has_exceptionalresult()
      ? *_impl_.result_.exceptionalresult_
      : reinterpret_cast< ::ExceptionalResult&>(::_ExceptionalResult_default_instance_);
}
inline const ::ExceptionalResult& RegisterProviderResponse::exceptionalresult() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.RegisterProviderResponse.exceptionalResult)
  return _internal_exceptionalresult();
}
inline ::ExceptionalResult* RegisterProviderResponse::unsafe_arena_release_exceptionalresult() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dp.service.ingestion.RegisterProviderResponse.exceptionalResult)
  if (_internal_has_exceptionalresult()) {
    clear_has_result();
    ::ExceptionalResult* temp = _impl_.result_.exceptionalresult_;
    _impl_.result_.exceptionalresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegisterProviderResponse::unsafe_arena_set_allocated_exceptionalresult(::ExceptionalResult* exceptionalresult) {
  clear_result();
  if (exceptionalresult) {
    set_has_exceptionalresult();
    _impl_.result_.exceptionalresult_ = exceptionalresult;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.RegisterProviderResponse.exceptionalResult)
}
inline ::ExceptionalResult* RegisterProviderResponse::_internal_mutable_exceptionalresult() {
  if (!_internal_has_exceptionalresult()) {
    clear_result();
    set_has_exceptionalresult();
    _impl_.result_.exceptionalresult_ = CreateMaybeMessage< ::ExceptionalResult >(GetArenaForAllocation());
  }
  return _impl_.result_.exceptionalresult_;
}
inline ::ExceptionalResult* RegisterProviderResponse::mutable_exceptionalresult() {
  ::ExceptionalResult* _msg = _internal_mutable_exceptionalresult();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.RegisterProviderResponse.exceptionalResult)
  return _msg;
}

// .dp.service.ingestion.RegisterProviderResponse.RegistrationResult registrationResult = 11;
inline bool RegisterProviderResponse::_internal_has_registrationresult() const {
  return result_case() == kRegistrationResult;
}
inline bool RegisterProviderResponse::has_registrationresult() const {
  return _internal_has_registrationresult();
}
inline void RegisterProviderResponse::set_has_registrationresult() {
  _impl_._oneof_case_[0] = kRegistrationResult;
}
inline void RegisterProviderResponse::clear_registrationresult() {
  if (_internal_has_registrationresult()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.result_.registrationresult_;
    }
    clear_has_result();
  }
}
inline ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* RegisterProviderResponse::release_registrationresult() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.RegisterProviderResponse.registrationResult)
  if (_internal_has_registrationresult()) {
    clear_has_result();
    ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* temp = _impl_.result_.registrationresult_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.registrationresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult& RegisterProviderResponse::_internal_registrationresult() const {
  return _internal_has_registrationresult()
      ? *_impl_.result_.registrationresult_
      : reinterpret_cast< ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult&>(::dp::service::ingestion::_RegisterProviderResponse_RegistrationResult_default_instance_);
}
inline const ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult& RegisterProviderResponse::registrationresult() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.RegisterProviderResponse.registrationResult)
  return _internal_registrationresult();
}
inline ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* RegisterProviderResponse::unsafe_arena_release_registrationresult() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dp.service.ingestion.RegisterProviderResponse.registrationResult)
  if (_internal_has_registrationresult()) {
    clear_has_result();
    ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* temp = _impl_.result_.registrationresult_;
    _impl_.result_.registrationresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegisterProviderResponse::unsafe_arena_set_allocated_registrationresult(::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* registrationresult) {
  clear_result();
  if (registrationresult) {
    set_has_registrationresult();
    _impl_.result_.registrationresult_ = registrationresult;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.RegisterProviderResponse.registrationResult)
}
inline ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* RegisterProviderResponse::_internal_mutable_registrationresult() {
  if (!_internal_has_registrationresult()) {
    clear_result();
    set_has_registrationresult();
    _impl_.result_.registrationresult_ = CreateMaybeMessage< ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult >(GetArenaForAllocation());
  }
  return _impl_.result_.registrationresult_;
}
inline ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* RegisterProviderResponse::mutable_registrationresult() {
  ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* _msg = _internal_mutable_registrationresult();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.RegisterProviderResponse.registrationResult)
  return _msg;
}

inline bool RegisterProviderResponse::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void RegisterProviderResponse::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline RegisterProviderResponse::ResultCase RegisterProviderResponse::result_case() const {
  return RegisterProviderResponse::ResultCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// IngestDataRequest_IngestionDataFrame

// .DataTimestamps dataTimestamps = 1;
inline bool IngestDataRequest_IngestionDataFrame::_internal_has_datatimestamps() const {
  return this != internal_default_instance() && _impl_.datatimestamps_ != nullptr;
}
inline bool IngestDataRequest_IngestionDataFrame::has_datatimestamps() const {
  return _internal_has_datatimestamps();
}
inline const ::DataTimestamps& IngestDataRequest_IngestionDataFrame::_internal_datatimestamps() const {
  const ::DataTimestamps* p = _impl_.datatimestamps_;
  return p != nullptr ? *p : reinterpret_cast<const ::DataTimestamps&>(
      ::_DataTimestamps_default_instance_);
}
inline const ::DataTimestamps& IngestDataRequest_IngestionDataFrame::datatimestamps() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataTimestamps)
  return _internal_datatimestamps();
}
inline void IngestDataRequest_IngestionDataFrame::unsafe_arena_set_allocated_datatimestamps(
    ::DataTimestamps* datatimestamps) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.datatimestamps_);
  }
  _impl_.datatimestamps_ = datatimestamps;
  if (datatimestamps) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataTimestamps)
}
inline ::DataTimestamps* IngestDataRequest_IngestionDataFrame::release_datatimestamps() {
  
  ::DataTimestamps* temp = _impl_.datatimestamps_;
  _impl_.datatimestamps_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DataTimestamps* IngestDataRequest_IngestionDataFrame::unsafe_arena_release_datatimestamps() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataTimestamps)
  
  ::DataTimestamps* temp = _impl_.datatimestamps_;
  _impl_.datatimestamps_ = nullptr;
  return temp;
}
inline ::DataTimestamps* IngestDataRequest_IngestionDataFrame::_internal_mutable_datatimestamps() {
  
  if (_impl_.datatimestamps_ == nullptr) {
    auto* p = CreateMaybeMessage<::DataTimestamps>(GetArenaForAllocation());
    _impl_.datatimestamps_ = p;
  }
  return _impl_.datatimestamps_;
}
inline ::DataTimestamps* IngestDataRequest_IngestionDataFrame::mutable_datatimestamps() {
  ::DataTimestamps* _msg = _internal_mutable_datatimestamps();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataTimestamps)
  return _msg;
}
inline void IngestDataRequest_IngestionDataFrame::set_allocated_datatimestamps(::DataTimestamps* datatimestamps) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.datatimestamps_);
  }
  if (datatimestamps) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(datatimestamps));
    if (message_arena != submessage_arena) {
      datatimestamps = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datatimestamps, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.datatimestamps_ = datatimestamps;
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataTimestamps)
}

// repeated .DataColumn dataColumns = 2;
inline int IngestDataRequest_IngestionDataFrame::_internal_datacolumns_size() const {
  return _impl_.datacolumns_.size();
}
inline int IngestDataRequest_IngestionDataFrame::datacolumns_size() const {
  return _internal_datacolumns_size();
}
inline ::DataColumn* IngestDataRequest_IngestionDataFrame::mutable_datacolumns(int index) {
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataColumns)
  return _impl_.datacolumns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataColumn >*
IngestDataRequest_IngestionDataFrame::mutable_datacolumns() {
  // @@protoc_insertion_point(field_mutable_list:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataColumns)
  return &_impl_.datacolumns_;
}
inline const ::DataColumn& IngestDataRequest_IngestionDataFrame::_internal_datacolumns(int index) const {
  return _impl_.datacolumns_.Get(index);
}
inline const ::DataColumn& IngestDataRequest_IngestionDataFrame::datacolumns(int index) const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataColumns)
  return _internal_datacolumns(index);
}
inline ::DataColumn* IngestDataRequest_IngestionDataFrame::_internal_add_datacolumns() {
  return _impl_.datacolumns_.Add();
}
inline ::DataColumn* IngestDataRequest_IngestionDataFrame::add_datacolumns() {
  ::DataColumn* _add = _internal_add_datacolumns();
  // @@protoc_insertion_point(field_add:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataColumns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DataColumn >&
IngestDataRequest_IngestionDataFrame::datacolumns() const {
  // @@protoc_insertion_point(field_list:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataColumns)
  return _impl_.datacolumns_;
}

// -------------------------------------------------------------------

// IngestDataRequest

// uint32 providerId = 1;
inline void IngestDataRequest::clear_providerid() {
  _impl_.providerid_ = 0u;
}
inline uint32_t IngestDataRequest::_internal_providerid() const {
  return _impl_.providerid_;
}
inline uint32_t IngestDataRequest::providerid() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.providerId)
  return _internal_providerid();
}
inline void IngestDataRequest::_internal_set_providerid(uint32_t value) {
  
  _impl_.providerid_ = value;
}
inline void IngestDataRequest::set_providerid(uint32_t value) {
  _internal_set_providerid(value);
  // @@protoc_insertion_point(field_set:dp.service.ingestion.IngestDataRequest.providerId)
}

// string clientRequestId = 2;
inline void IngestDataRequest::clear_clientrequestid() {
  _impl_.clientrequestid_.ClearToEmpty();
}
inline const std::string& IngestDataRequest::clientrequestid() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.clientRequestId)
  return _internal_clientrequestid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngestDataRequest::set_clientrequestid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientrequestid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dp.service.ingestion.IngestDataRequest.clientRequestId)
}
inline std::string* IngestDataRequest::mutable_clientrequestid() {
  std::string* _s = _internal_mutable_clientrequestid();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataRequest.clientRequestId)
  return _s;
}
inline const std::string& IngestDataRequest::_internal_clientrequestid() const {
  return _impl_.clientrequestid_.Get();
}
inline void IngestDataRequest::_internal_set_clientrequestid(const std::string& value) {
  
  _impl_.clientrequestid_.Set(value, GetArenaForAllocation());
}
inline std::string* IngestDataRequest::_internal_mutable_clientrequestid() {
  
  return _impl_.clientrequestid_.Mutable(GetArenaForAllocation());
}
inline std::string* IngestDataRequest::release_clientrequestid() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataRequest.clientRequestId)
  return _impl_.clientrequestid_.Release();
}
inline void IngestDataRequest::set_allocated_clientrequestid(std::string* clientrequestid) {
  if (clientrequestid != nullptr) {
    
  } else {
    
  }
  _impl_.clientrequestid_.SetAllocated(clientrequestid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientrequestid_.IsDefault()) {
    _impl_.clientrequestid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.IngestDataRequest.clientRequestId)
}

// .Timestamp requestTime = 3;
inline bool IngestDataRequest::_internal_has_requesttime() const {
  return this != internal_default_instance() && _impl_.requesttime_ != nullptr;
}
inline bool IngestDataRequest::has_requesttime() const {
  return _internal_has_requesttime();
}
inline const ::Timestamp& IngestDataRequest::_internal_requesttime() const {
  const ::Timestamp* p = _impl_.requesttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::Timestamp&>(
      ::_Timestamp_default_instance_);
}
inline const ::Timestamp& IngestDataRequest::requesttime() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.requestTime)
  return _internal_requesttime();
}
inline void IngestDataRequest::unsafe_arena_set_allocated_requesttime(
    ::Timestamp* requesttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requesttime_);
  }
  _impl_.requesttime_ = requesttime;
  if (requesttime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.IngestDataRequest.requestTime)
}
inline ::Timestamp* IngestDataRequest::release_requesttime() {
  
  ::Timestamp* temp = _impl_.requesttime_;
  _impl_.requesttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Timestamp* IngestDataRequest::unsafe_arena_release_requesttime() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataRequest.requestTime)
  
  ::Timestamp* temp = _impl_.requesttime_;
  _impl_.requesttime_ = nullptr;
  return temp;
}
inline ::Timestamp* IngestDataRequest::_internal_mutable_requesttime() {
  
  if (_impl_.requesttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::Timestamp>(GetArenaForAllocation());
    _impl_.requesttime_ = p;
  }
  return _impl_.requesttime_;
}
inline ::Timestamp* IngestDataRequest::mutable_requesttime() {
  ::Timestamp* _msg = _internal_mutable_requesttime();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataRequest.requestTime)
  return _msg;
}
inline void IngestDataRequest::set_allocated_requesttime(::Timestamp* requesttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requesttime_);
  }
  if (requesttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(requesttime));
    if (message_arena != submessage_arena) {
      requesttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requesttime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.requesttime_ = requesttime;
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.IngestDataRequest.requestTime)
}

// repeated .Attribute attributes = 4;
inline int IngestDataRequest::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int IngestDataRequest::attributes_size() const {
  return _internal_attributes_size();
}
inline ::Attribute* IngestDataRequest::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataRequest.attributes)
  return _impl_.attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Attribute >*
IngestDataRequest::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:dp.service.ingestion.IngestDataRequest.attributes)
  return &_impl_.attributes_;
}
inline const ::Attribute& IngestDataRequest::_internal_attributes(int index) const {
  return _impl_.attributes_.Get(index);
}
inline const ::Attribute& IngestDataRequest::attributes(int index) const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.attributes)
  return _internal_attributes(index);
}
inline ::Attribute* IngestDataRequest::_internal_add_attributes() {
  return _impl_.attributes_.Add();
}
inline ::Attribute* IngestDataRequest::add_attributes() {
  ::Attribute* _add = _internal_add_attributes();
  // @@protoc_insertion_point(field_add:dp.service.ingestion.IngestDataRequest.attributes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Attribute >&
IngestDataRequest::attributes() const {
  // @@protoc_insertion_point(field_list:dp.service.ingestion.IngestDataRequest.attributes)
  return _impl_.attributes_;
}

// .EventMetadata eventMetadata = 5;
inline bool IngestDataRequest::_internal_has_eventmetadata() const {
  return this != internal_default_instance() && _impl_.eventmetadata_ != nullptr;
}
inline bool IngestDataRequest::has_eventmetadata() const {
  return _internal_has_eventmetadata();
}
inline const ::EventMetadata& IngestDataRequest::_internal_eventmetadata() const {
  const ::EventMetadata* p = _impl_.eventmetadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::EventMetadata&>(
      ::_EventMetadata_default_instance_);
}
inline const ::EventMetadata& IngestDataRequest::eventmetadata() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.eventMetadata)
  return _internal_eventmetadata();
}
inline void IngestDataRequest::unsafe_arena_set_allocated_eventmetadata(
    ::EventMetadata* eventmetadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmetadata_);
  }
  _impl_.eventmetadata_ = eventmetadata;
  if (eventmetadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.IngestDataRequest.eventMetadata)
}
inline ::EventMetadata* IngestDataRequest::release_eventmetadata() {
  
  ::EventMetadata* temp = _impl_.eventmetadata_;
  _impl_.eventmetadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::EventMetadata* IngestDataRequest::unsafe_arena_release_eventmetadata() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataRequest.eventMetadata)
  
  ::EventMetadata* temp = _impl_.eventmetadata_;
  _impl_.eventmetadata_ = nullptr;
  return temp;
}
inline ::EventMetadata* IngestDataRequest::_internal_mutable_eventmetadata() {
  
  if (_impl_.eventmetadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::EventMetadata>(GetArenaForAllocation());
    _impl_.eventmetadata_ = p;
  }
  return _impl_.eventmetadata_;
}
inline ::EventMetadata* IngestDataRequest::mutable_eventmetadata() {
  ::EventMetadata* _msg = _internal_mutable_eventmetadata();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataRequest.eventMetadata)
  return _msg;
}
inline void IngestDataRequest::set_allocated_eventmetadata(::EventMetadata* eventmetadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eventmetadata_);
  }
  if (eventmetadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eventmetadata));
    if (message_arena != submessage_arena) {
      eventmetadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eventmetadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.eventmetadata_ = eventmetadata;
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.IngestDataRequest.eventMetadata)
}

// .dp.service.ingestion.IngestDataRequest.IngestionDataFrame ingestionDataFrame = 6;
inline bool IngestDataRequest::_internal_has_ingestiondataframe() const {
  return this != internal_default_instance() && _impl_.ingestiondataframe_ != nullptr;
}
inline bool IngestDataRequest::has_ingestiondataframe() const {
  return _internal_has_ingestiondataframe();
}
inline void IngestDataRequest::clear_ingestiondataframe() {
  if (GetArenaForAllocation() == nullptr && _impl_.ingestiondataframe_ != nullptr) {
    delete _impl_.ingestiondataframe_;
  }
  _impl_.ingestiondataframe_ = nullptr;
}
inline const ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame& IngestDataRequest::_internal_ingestiondataframe() const {
  const ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* p = _impl_.ingestiondataframe_;
  return p != nullptr ? *p : reinterpret_cast<const ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame&>(
      ::dp::service::ingestion::_IngestDataRequest_IngestionDataFrame_default_instance_);
}
inline const ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame& IngestDataRequest::ingestiondataframe() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.ingestionDataFrame)
  return _internal_ingestiondataframe();
}
inline void IngestDataRequest::unsafe_arena_set_allocated_ingestiondataframe(
    ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* ingestiondataframe) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ingestiondataframe_);
  }
  _impl_.ingestiondataframe_ = ingestiondataframe;
  if (ingestiondataframe) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.IngestDataRequest.ingestionDataFrame)
}
inline ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* IngestDataRequest::release_ingestiondataframe() {
  
  ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* temp = _impl_.ingestiondataframe_;
  _impl_.ingestiondataframe_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* IngestDataRequest::unsafe_arena_release_ingestiondataframe() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataRequest.ingestionDataFrame)
  
  ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* temp = _impl_.ingestiondataframe_;
  _impl_.ingestiondataframe_ = nullptr;
  return temp;
}
inline ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* IngestDataRequest::_internal_mutable_ingestiondataframe() {
  
  if (_impl_.ingestiondataframe_ == nullptr) {
    auto* p = CreateMaybeMessage<::dp::service::ingestion::IngestDataRequest_IngestionDataFrame>(GetArenaForAllocation());
    _impl_.ingestiondataframe_ = p;
  }
  return _impl_.ingestiondataframe_;
}
inline ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* IngestDataRequest::mutable_ingestiondataframe() {
  ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* _msg = _internal_mutable_ingestiondataframe();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataRequest.ingestionDataFrame)
  return _msg;
}
inline void IngestDataRequest::set_allocated_ingestiondataframe(::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* ingestiondataframe) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ingestiondataframe_;
  }
  if (ingestiondataframe) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ingestiondataframe);
    if (message_arena != submessage_arena) {
      ingestiondataframe = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ingestiondataframe, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ingestiondataframe_ = ingestiondataframe;
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.IngestDataRequest.ingestionDataFrame)
}

// -------------------------------------------------------------------

// IngestDataResponse_AckResult

// uint32 numRows = 1;
inline void IngestDataResponse_AckResult::clear_numrows() {
  _impl_.numrows_ = 0u;
}
inline uint32_t IngestDataResponse_AckResult::_internal_numrows() const {
  return _impl_.numrows_;
}
inline uint32_t IngestDataResponse_AckResult::numrows() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataResponse.AckResult.numRows)
  return _internal_numrows();
}
inline void IngestDataResponse_AckResult::_internal_set_numrows(uint32_t value) {
  
  _impl_.numrows_ = value;
}
inline void IngestDataResponse_AckResult::set_numrows(uint32_t value) {
  _internal_set_numrows(value);
  // @@protoc_insertion_point(field_set:dp.service.ingestion.IngestDataResponse.AckResult.numRows)
}

// uint32 numColumns = 2;
inline void IngestDataResponse_AckResult::clear_numcolumns() {
  _impl_.numcolumns_ = 0u;
}
inline uint32_t IngestDataResponse_AckResult::_internal_numcolumns() const {
  return _impl_.numcolumns_;
}
inline uint32_t IngestDataResponse_AckResult::numcolumns() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataResponse.AckResult.numColumns)
  return _internal_numcolumns();
}
inline void IngestDataResponse_AckResult::_internal_set_numcolumns(uint32_t value) {
  
  _impl_.numcolumns_ = value;
}
inline void IngestDataResponse_AckResult::set_numcolumns(uint32_t value) {
  _internal_set_numcolumns(value);
  // @@protoc_insertion_point(field_set:dp.service.ingestion.IngestDataResponse.AckResult.numColumns)
}

// -------------------------------------------------------------------

// IngestDataResponse

// uint32 providerId = 1;
inline void IngestDataResponse::clear_providerid() {
  _impl_.providerid_ = 0u;
}
inline uint32_t IngestDataResponse::_internal_providerid() const {
  return _impl_.providerid_;
}
inline uint32_t IngestDataResponse::providerid() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataResponse.providerId)
  return _internal_providerid();
}
inline void IngestDataResponse::_internal_set_providerid(uint32_t value) {
  
  _impl_.providerid_ = value;
}
inline void IngestDataResponse::set_providerid(uint32_t value) {
  _internal_set_providerid(value);
  // @@protoc_insertion_point(field_set:dp.service.ingestion.IngestDataResponse.providerId)
}

// string clientRequestId = 2;
inline void IngestDataResponse::clear_clientrequestid() {
  _impl_.clientrequestid_.ClearToEmpty();
}
inline const std::string& IngestDataResponse::clientrequestid() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataResponse.clientRequestId)
  return _internal_clientrequestid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngestDataResponse::set_clientrequestid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientrequestid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dp.service.ingestion.IngestDataResponse.clientRequestId)
}
inline std::string* IngestDataResponse::mutable_clientrequestid() {
  std::string* _s = _internal_mutable_clientrequestid();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataResponse.clientRequestId)
  return _s;
}
inline const std::string& IngestDataResponse::_internal_clientrequestid() const {
  return _impl_.clientrequestid_.Get();
}
inline void IngestDataResponse::_internal_set_clientrequestid(const std::string& value) {
  
  _impl_.clientrequestid_.Set(value, GetArenaForAllocation());
}
inline std::string* IngestDataResponse::_internal_mutable_clientrequestid() {
  
  return _impl_.clientrequestid_.Mutable(GetArenaForAllocation());
}
inline std::string* IngestDataResponse::release_clientrequestid() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataResponse.clientRequestId)
  return _impl_.clientrequestid_.Release();
}
inline void IngestDataResponse::set_allocated_clientrequestid(std::string* clientrequestid) {
  if (clientrequestid != nullptr) {
    
  } else {
    
  }
  _impl_.clientrequestid_.SetAllocated(clientrequestid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientrequestid_.IsDefault()) {
    _impl_.clientrequestid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.IngestDataResponse.clientRequestId)
}

// .Timestamp responseTime = 3;
inline bool IngestDataResponse::_internal_has_responsetime() const {
  return this != internal_default_instance() && _impl_.responsetime_ != nullptr;
}
inline bool IngestDataResponse::has_responsetime() const {
  return _internal_has_responsetime();
}
inline const ::Timestamp& IngestDataResponse::_internal_responsetime() const {
  const ::Timestamp* p = _impl_.responsetime_;
  return p != nullptr ? *p : reinterpret_cast<const ::Timestamp&>(
      ::_Timestamp_default_instance_);
}
inline const ::Timestamp& IngestDataResponse::responsetime() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataResponse.responseTime)
  return _internal_responsetime();
}
inline void IngestDataResponse::unsafe_arena_set_allocated_responsetime(
    ::Timestamp* responsetime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.responsetime_);
  }
  _impl_.responsetime_ = responsetime;
  if (responsetime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.IngestDataResponse.responseTime)
}
inline ::Timestamp* IngestDataResponse::release_responsetime() {
  
  ::Timestamp* temp = _impl_.responsetime_;
  _impl_.responsetime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Timestamp* IngestDataResponse::unsafe_arena_release_responsetime() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataResponse.responseTime)
  
  ::Timestamp* temp = _impl_.responsetime_;
  _impl_.responsetime_ = nullptr;
  return temp;
}
inline ::Timestamp* IngestDataResponse::_internal_mutable_responsetime() {
  
  if (_impl_.responsetime_ == nullptr) {
    auto* p = CreateMaybeMessage<::Timestamp>(GetArenaForAllocation());
    _impl_.responsetime_ = p;
  }
  return _impl_.responsetime_;
}
inline ::Timestamp* IngestDataResponse::mutable_responsetime() {
  ::Timestamp* _msg = _internal_mutable_responsetime();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataResponse.responseTime)
  return _msg;
}
inline void IngestDataResponse::set_allocated_responsetime(::Timestamp* responsetime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.responsetime_);
  }
  if (responsetime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(responsetime));
    if (message_arena != submessage_arena) {
      responsetime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, responsetime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.responsetime_ = responsetime;
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.IngestDataResponse.responseTime)
}

// .ExceptionalResult exceptionalResult = 10;
inline bool IngestDataResponse::_internal_has_exceptionalresult() const {
  return result_case() == kExceptionalResult;
}
inline bool IngestDataResponse::has_exceptionalresult() const {
  return _internal_has_exceptionalresult();
}
inline void IngestDataResponse::set_has_exceptionalresult() {
  _impl_._oneof_case_[0] = kExceptionalResult;
}
inline ::ExceptionalResult* IngestDataResponse::release_exceptionalresult() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataResponse.exceptionalResult)
  if (_internal_has_exceptionalresult()) {
    clear_has_result();
    ::ExceptionalResult* temp = _impl_.result_.exceptionalresult_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.exceptionalresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ExceptionalResult& IngestDataResponse::_internal_exceptionalresult() const {
  return _internal_has_exceptionalresult()
      ? *_impl_.result_.exceptionalresult_
      : reinterpret_cast< ::ExceptionalResult&>(::_ExceptionalResult_default_instance_);
}
inline const ::ExceptionalResult& IngestDataResponse::exceptionalresult() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataResponse.exceptionalResult)
  return _internal_exceptionalresult();
}
inline ::ExceptionalResult* IngestDataResponse::unsafe_arena_release_exceptionalresult() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dp.service.ingestion.IngestDataResponse.exceptionalResult)
  if (_internal_has_exceptionalresult()) {
    clear_has_result();
    ::ExceptionalResult* temp = _impl_.result_.exceptionalresult_;
    _impl_.result_.exceptionalresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IngestDataResponse::unsafe_arena_set_allocated_exceptionalresult(::ExceptionalResult* exceptionalresult) {
  clear_result();
  if (exceptionalresult) {
    set_has_exceptionalresult();
    _impl_.result_.exceptionalresult_ = exceptionalresult;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.IngestDataResponse.exceptionalResult)
}
inline ::ExceptionalResult* IngestDataResponse::_internal_mutable_exceptionalresult() {
  if (!_internal_has_exceptionalresult()) {
    clear_result();
    set_has_exceptionalresult();
    _impl_.result_.exceptionalresult_ = CreateMaybeMessage< ::ExceptionalResult >(GetArenaForAllocation());
  }
  return _impl_.result_.exceptionalresult_;
}
inline ::ExceptionalResult* IngestDataResponse::mutable_exceptionalresult() {
  ::ExceptionalResult* _msg = _internal_mutable_exceptionalresult();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataResponse.exceptionalResult)
  return _msg;
}

// .dp.service.ingestion.IngestDataResponse.AckResult ackResult = 11;
inline bool IngestDataResponse::_internal_has_ackresult() const {
  return result_case() == kAckResult;
}
inline bool IngestDataResponse::has_ackresult() const {
  return _internal_has_ackresult();
}
inline void IngestDataResponse::set_has_ackresult() {
  _impl_._oneof_case_[0] = kAckResult;
}
inline void IngestDataResponse::clear_ackresult() {
  if (_internal_has_ackresult()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.result_.ackresult_;
    }
    clear_has_result();
  }
}
inline ::dp::service::ingestion::IngestDataResponse_AckResult* IngestDataResponse::release_ackresult() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataResponse.ackResult)
  if (_internal_has_ackresult()) {
    clear_has_result();
    ::dp::service::ingestion::IngestDataResponse_AckResult* temp = _impl_.result_.ackresult_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.ackresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dp::service::ingestion::IngestDataResponse_AckResult& IngestDataResponse::_internal_ackresult() const {
  return _internal_has_ackresult()
      ? *_impl_.result_.ackresult_
      : reinterpret_cast< ::dp::service::ingestion::IngestDataResponse_AckResult&>(::dp::service::ingestion::_IngestDataResponse_AckResult_default_instance_);
}
inline const ::dp::service::ingestion::IngestDataResponse_AckResult& IngestDataResponse::ackresult() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataResponse.ackResult)
  return _internal_ackresult();
}
inline ::dp::service::ingestion::IngestDataResponse_AckResult* IngestDataResponse::unsafe_arena_release_ackresult() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dp.service.ingestion.IngestDataResponse.ackResult)
  if (_internal_has_ackresult()) {
    clear_has_result();
    ::dp::service::ingestion::IngestDataResponse_AckResult* temp = _impl_.result_.ackresult_;
    _impl_.result_.ackresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IngestDataResponse::unsafe_arena_set_allocated_ackresult(::dp::service::ingestion::IngestDataResponse_AckResult* ackresult) {
  clear_result();
  if (ackresult) {
    set_has_ackresult();
    _impl_.result_.ackresult_ = ackresult;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.IngestDataResponse.ackResult)
}
inline ::dp::service::ingestion::IngestDataResponse_AckResult* IngestDataResponse::_internal_mutable_ackresult() {
  if (!_internal_has_ackresult()) {
    clear_result();
    set_has_ackresult();
    _impl_.result_.ackresult_ = CreateMaybeMessage< ::dp::service::ingestion::IngestDataResponse_AckResult >(GetArenaForAllocation());
  }
  return _impl_.result_.ackresult_;
}
inline ::dp::service::ingestion::IngestDataResponse_AckResult* IngestDataResponse::mutable_ackresult() {
  ::dp::service::ingestion::IngestDataResponse_AckResult* _msg = _internal_mutable_ackresult();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataResponse.ackResult)
  return _msg;
}

inline bool IngestDataResponse::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void IngestDataResponse::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline IngestDataResponse::ResultCase IngestDataResponse::result_case() const {
  return IngestDataResponse::ResultCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ingestion
}  // namespace service
}  // namespace dp

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ingestion_2eproto
