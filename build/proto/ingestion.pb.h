// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ingestion.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_ingestion_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ingestion_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ingestion_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ingestion_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_ingestion_2eproto;
namespace dp {
namespace service {
namespace ingestion {
class IngestDataRequest;
struct IngestDataRequestDefaultTypeInternal;
extern IngestDataRequestDefaultTypeInternal _IngestDataRequest_default_instance_;
class IngestDataRequest_IngestionDataFrame;
struct IngestDataRequest_IngestionDataFrameDefaultTypeInternal;
extern IngestDataRequest_IngestionDataFrameDefaultTypeInternal _IngestDataRequest_IngestionDataFrame_default_instance_;
class IngestDataResponse;
struct IngestDataResponseDefaultTypeInternal;
extern IngestDataResponseDefaultTypeInternal _IngestDataResponse_default_instance_;
class IngestDataResponse_AckResult;
struct IngestDataResponse_AckResultDefaultTypeInternal;
extern IngestDataResponse_AckResultDefaultTypeInternal _IngestDataResponse_AckResult_default_instance_;
class RegisterProviderRequest;
struct RegisterProviderRequestDefaultTypeInternal;
extern RegisterProviderRequestDefaultTypeInternal _RegisterProviderRequest_default_instance_;
class RegisterProviderResponse;
struct RegisterProviderResponseDefaultTypeInternal;
extern RegisterProviderResponseDefaultTypeInternal _RegisterProviderResponse_default_instance_;
class RegisterProviderResponse_RegistrationResult;
struct RegisterProviderResponse_RegistrationResultDefaultTypeInternal;
extern RegisterProviderResponse_RegistrationResultDefaultTypeInternal _RegisterProviderResponse_RegistrationResult_default_instance_;
}  // namespace ingestion
}  // namespace service
}  // namespace dp
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace dp {
namespace service {
namespace ingestion {

// ===================================================================


// -------------------------------------------------------------------

class RegisterProviderResponse_RegistrationResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dp.service.ingestion.RegisterProviderResponse.RegistrationResult) */ {
 public:
  inline RegisterProviderResponse_RegistrationResult() : RegisterProviderResponse_RegistrationResult(nullptr) {}
  ~RegisterProviderResponse_RegistrationResult() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterProviderResponse_RegistrationResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterProviderResponse_RegistrationResult(const RegisterProviderResponse_RegistrationResult& from) : RegisterProviderResponse_RegistrationResult(nullptr, from) {}
  inline RegisterProviderResponse_RegistrationResult(RegisterProviderResponse_RegistrationResult&& from) noexcept
      : RegisterProviderResponse_RegistrationResult(nullptr, std::move(from)) {}
  inline RegisterProviderResponse_RegistrationResult& operator=(const RegisterProviderResponse_RegistrationResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterProviderResponse_RegistrationResult& operator=(RegisterProviderResponse_RegistrationResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterProviderResponse_RegistrationResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterProviderResponse_RegistrationResult* internal_default_instance() {
    return reinterpret_cast<const RegisterProviderResponse_RegistrationResult*>(
        &_RegisterProviderResponse_RegistrationResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(RegisterProviderResponse_RegistrationResult& a, RegisterProviderResponse_RegistrationResult& b) { a.Swap(&b); }
  inline void Swap(RegisterProviderResponse_RegistrationResult* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterProviderResponse_RegistrationResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterProviderResponse_RegistrationResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterProviderResponse_RegistrationResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterProviderResponse_RegistrationResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterProviderResponse_RegistrationResult& from) { RegisterProviderResponse_RegistrationResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterProviderResponse_RegistrationResult* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dp.service.ingestion.RegisterProviderResponse.RegistrationResult"; }

 protected:
  explicit RegisterProviderResponse_RegistrationResult(::google::protobuf::Arena* arena);
  RegisterProviderResponse_RegistrationResult(::google::protobuf::Arena* arena, const RegisterProviderResponse_RegistrationResult& from);
  RegisterProviderResponse_RegistrationResult(::google::protobuf::Arena* arena, RegisterProviderResponse_RegistrationResult&& from) noexcept
      : RegisterProviderResponse_RegistrationResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kProviderIdFieldNumber = 1,
  };
  // uint32 providerId = 1;
  void clear_providerid() ;
  ::uint32_t providerid() const;
  void set_providerid(::uint32_t value);

  private:
  ::uint32_t _internal_providerid() const;
  void _internal_set_providerid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dp.service.ingestion.RegisterProviderResponse.RegistrationResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t providerid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ingestion_2eproto;
};
// -------------------------------------------------------------------

class IngestDataResponse_AckResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dp.service.ingestion.IngestDataResponse.AckResult) */ {
 public:
  inline IngestDataResponse_AckResult() : IngestDataResponse_AckResult(nullptr) {}
  ~IngestDataResponse_AckResult() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IngestDataResponse_AckResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline IngestDataResponse_AckResult(const IngestDataResponse_AckResult& from) : IngestDataResponse_AckResult(nullptr, from) {}
  inline IngestDataResponse_AckResult(IngestDataResponse_AckResult&& from) noexcept
      : IngestDataResponse_AckResult(nullptr, std::move(from)) {}
  inline IngestDataResponse_AckResult& operator=(const IngestDataResponse_AckResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngestDataResponse_AckResult& operator=(IngestDataResponse_AckResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngestDataResponse_AckResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const IngestDataResponse_AckResult* internal_default_instance() {
    return reinterpret_cast<const IngestDataResponse_AckResult*>(
        &_IngestDataResponse_AckResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(IngestDataResponse_AckResult& a, IngestDataResponse_AckResult& b) { a.Swap(&b); }
  inline void Swap(IngestDataResponse_AckResult* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngestDataResponse_AckResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngestDataResponse_AckResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<IngestDataResponse_AckResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IngestDataResponse_AckResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IngestDataResponse_AckResult& from) { IngestDataResponse_AckResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IngestDataResponse_AckResult* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dp.service.ingestion.IngestDataResponse.AckResult"; }

 protected:
  explicit IngestDataResponse_AckResult(::google::protobuf::Arena* arena);
  IngestDataResponse_AckResult(::google::protobuf::Arena* arena, const IngestDataResponse_AckResult& from);
  IngestDataResponse_AckResult(::google::protobuf::Arena* arena, IngestDataResponse_AckResult&& from) noexcept
      : IngestDataResponse_AckResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNumRowsFieldNumber = 1,
    kNumColumnsFieldNumber = 2,
  };
  // uint32 numRows = 1;
  void clear_numrows() ;
  ::uint32_t numrows() const;
  void set_numrows(::uint32_t value);

  private:
  ::uint32_t _internal_numrows() const;
  void _internal_set_numrows(::uint32_t value);

  public:
  // uint32 numColumns = 2;
  void clear_numcolumns() ;
  ::uint32_t numcolumns() const;
  void set_numcolumns(::uint32_t value);

  private:
  ::uint32_t _internal_numcolumns() const;
  void _internal_set_numcolumns(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dp.service.ingestion.IngestDataResponse.AckResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t numrows_;
    ::uint32_t numcolumns_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ingestion_2eproto;
};
// -------------------------------------------------------------------

class RegisterProviderResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dp.service.ingestion.RegisterProviderResponse) */ {
 public:
  inline RegisterProviderResponse() : RegisterProviderResponse(nullptr) {}
  ~RegisterProviderResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterProviderResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterProviderResponse(const RegisterProviderResponse& from) : RegisterProviderResponse(nullptr, from) {}
  inline RegisterProviderResponse(RegisterProviderResponse&& from) noexcept
      : RegisterProviderResponse(nullptr, std::move(from)) {}
  inline RegisterProviderResponse& operator=(const RegisterProviderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterProviderResponse& operator=(RegisterProviderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterProviderResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kExceptionalResult = 10,
    kRegistrationResult = 11,
    RESULT_NOT_SET = 0,
  };
  static inline const RegisterProviderResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterProviderResponse*>(
        &_RegisterProviderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(RegisterProviderResponse& a, RegisterProviderResponse& b) { a.Swap(&b); }
  inline void Swap(RegisterProviderResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterProviderResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterProviderResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterProviderResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterProviderResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterProviderResponse& from) { RegisterProviderResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterProviderResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dp.service.ingestion.RegisterProviderResponse"; }

 protected:
  explicit RegisterProviderResponse(::google::protobuf::Arena* arena);
  RegisterProviderResponse(::google::protobuf::Arena* arena, const RegisterProviderResponse& from);
  RegisterProviderResponse(::google::protobuf::Arena* arena, RegisterProviderResponse&& from) noexcept
      : RegisterProviderResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using RegistrationResult = RegisterProviderResponse_RegistrationResult;

  // accessors -------------------------------------------------------
  enum : int {
    kResponseTimeFieldNumber = 1,
    kExceptionalResultFieldNumber = 10,
    kRegistrationResultFieldNumber = 11,
  };
  // .Timestamp responseTime = 1;
  bool has_responsetime() const;
  void clear_responsetime() ;
  const ::Timestamp& responsetime() const;
  PROTOBUF_NODISCARD ::Timestamp* release_responsetime();
  ::Timestamp* mutable_responsetime();
  void set_allocated_responsetime(::Timestamp* value);
  void unsafe_arena_set_allocated_responsetime(::Timestamp* value);
  ::Timestamp* unsafe_arena_release_responsetime();

  private:
  const ::Timestamp& _internal_responsetime() const;
  ::Timestamp* _internal_mutable_responsetime();

  public:
  // .ExceptionalResult exceptionalResult = 10;
  bool has_exceptionalresult() const;
  private:
  bool _internal_has_exceptionalresult() const;

  public:
  void clear_exceptionalresult() ;
  const ::ExceptionalResult& exceptionalresult() const;
  PROTOBUF_NODISCARD ::ExceptionalResult* release_exceptionalresult();
  ::ExceptionalResult* mutable_exceptionalresult();
  void set_allocated_exceptionalresult(::ExceptionalResult* value);
  void unsafe_arena_set_allocated_exceptionalresult(::ExceptionalResult* value);
  ::ExceptionalResult* unsafe_arena_release_exceptionalresult();

  private:
  const ::ExceptionalResult& _internal_exceptionalresult() const;
  ::ExceptionalResult* _internal_mutable_exceptionalresult();

  public:
  // .dp.service.ingestion.RegisterProviderResponse.RegistrationResult registrationResult = 11;
  bool has_registrationresult() const;
  private:
  bool _internal_has_registrationresult() const;

  public:
  void clear_registrationresult() ;
  const ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult& registrationresult() const;
  PROTOBUF_NODISCARD ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* release_registrationresult();
  ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* mutable_registrationresult();
  void set_allocated_registrationresult(::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* value);
  void unsafe_arena_set_allocated_registrationresult(::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* value);
  ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* unsafe_arena_release_registrationresult();

  private:
  const ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult& _internal_registrationresult() const;
  ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* _internal_mutable_registrationresult();

  public:
  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:dp.service.ingestion.RegisterProviderResponse)
 private:
  class _Internal;
  void set_has_exceptionalresult();
  void set_has_registrationresult();
  inline bool has_result() const;
  inline void clear_has_result();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Timestamp* responsetime_;
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::ExceptionalResult* exceptionalresult_;
      ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* registrationresult_;
    } result_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ingestion_2eproto;
};
// -------------------------------------------------------------------

class RegisterProviderRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dp.service.ingestion.RegisterProviderRequest) */ {
 public:
  inline RegisterProviderRequest() : RegisterProviderRequest(nullptr) {}
  ~RegisterProviderRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterProviderRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterProviderRequest(const RegisterProviderRequest& from) : RegisterProviderRequest(nullptr, from) {}
  inline RegisterProviderRequest(RegisterProviderRequest&& from) noexcept
      : RegisterProviderRequest(nullptr, std::move(from)) {}
  inline RegisterProviderRequest& operator=(const RegisterProviderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterProviderRequest& operator=(RegisterProviderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterProviderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterProviderRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterProviderRequest*>(
        &_RegisterProviderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(RegisterProviderRequest& a, RegisterProviderRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterProviderRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterProviderRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterProviderRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterProviderRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterProviderRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterProviderRequest& from) { RegisterProviderRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterProviderRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dp.service.ingestion.RegisterProviderRequest"; }

 protected:
  explicit RegisterProviderRequest(::google::protobuf::Arena* arena);
  RegisterProviderRequest(::google::protobuf::Arena* arena, const RegisterProviderRequest& from);
  RegisterProviderRequest(::google::protobuf::Arena* arena, RegisterProviderRequest&& from) noexcept
      : RegisterProviderRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAttributesFieldNumber = 2,
    kProviderNameFieldNumber = 1,
    kRequestTimeFieldNumber = 3,
  };
  // repeated .Attribute attributes = 2;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField<::Attribute>* mutable_attributes();

  private:
  const ::google::protobuf::RepeatedPtrField<::Attribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::Attribute>* _internal_mutable_attributes();
  public:
  const ::Attribute& attributes(int index) const;
  ::Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField<::Attribute>& attributes() const;
  // string providerName = 1;
  void clear_providername() ;
  const std::string& providername() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_providername(Arg_&& arg, Args_... args);
  std::string* mutable_providername();
  PROTOBUF_NODISCARD std::string* release_providername();
  void set_allocated_providername(std::string* value);

  private:
  const std::string& _internal_providername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_providername(
      const std::string& value);
  std::string* _internal_mutable_providername();

  public:
  // .Timestamp requestTime = 3;
  bool has_requesttime() const;
  void clear_requesttime() ;
  const ::Timestamp& requesttime() const;
  PROTOBUF_NODISCARD ::Timestamp* release_requesttime();
  ::Timestamp* mutable_requesttime();
  void set_allocated_requesttime(::Timestamp* value);
  void unsafe_arena_set_allocated_requesttime(::Timestamp* value);
  ::Timestamp* unsafe_arena_release_requesttime();

  private:
  const ::Timestamp& _internal_requesttime() const;
  ::Timestamp* _internal_mutable_requesttime();

  public:
  // @@protoc_insertion_point(class_scope:dp.service.ingestion.RegisterProviderRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      65, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::Attribute > attributes_;
    ::google::protobuf::internal::ArenaStringPtr providername_;
    ::Timestamp* requesttime_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ingestion_2eproto;
};
// -------------------------------------------------------------------

class IngestDataResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dp.service.ingestion.IngestDataResponse) */ {
 public:
  inline IngestDataResponse() : IngestDataResponse(nullptr) {}
  ~IngestDataResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IngestDataResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline IngestDataResponse(const IngestDataResponse& from) : IngestDataResponse(nullptr, from) {}
  inline IngestDataResponse(IngestDataResponse&& from) noexcept
      : IngestDataResponse(nullptr, std::move(from)) {}
  inline IngestDataResponse& operator=(const IngestDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngestDataResponse& operator=(IngestDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngestDataResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kExceptionalResult = 10,
    kAckResult = 11,
    RESULT_NOT_SET = 0,
  };
  static inline const IngestDataResponse* internal_default_instance() {
    return reinterpret_cast<const IngestDataResponse*>(
        &_IngestDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(IngestDataResponse& a, IngestDataResponse& b) { a.Swap(&b); }
  inline void Swap(IngestDataResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngestDataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngestDataResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<IngestDataResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IngestDataResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IngestDataResponse& from) { IngestDataResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IngestDataResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dp.service.ingestion.IngestDataResponse"; }

 protected:
  explicit IngestDataResponse(::google::protobuf::Arena* arena);
  IngestDataResponse(::google::protobuf::Arena* arena, const IngestDataResponse& from);
  IngestDataResponse(::google::protobuf::Arena* arena, IngestDataResponse&& from) noexcept
      : IngestDataResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using AckResult = IngestDataResponse_AckResult;

  // accessors -------------------------------------------------------
  enum : int {
    kClientRequestIdFieldNumber = 2,
    kResponseTimeFieldNumber = 3,
    kProviderIdFieldNumber = 1,
    kExceptionalResultFieldNumber = 10,
    kAckResultFieldNumber = 11,
  };
  // string clientRequestId = 2;
  void clear_clientrequestid() ;
  const std::string& clientrequestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientrequestid(Arg_&& arg, Args_... args);
  std::string* mutable_clientrequestid();
  PROTOBUF_NODISCARD std::string* release_clientrequestid();
  void set_allocated_clientrequestid(std::string* value);

  private:
  const std::string& _internal_clientrequestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientrequestid(
      const std::string& value);
  std::string* _internal_mutable_clientrequestid();

  public:
  // .Timestamp responseTime = 3;
  bool has_responsetime() const;
  void clear_responsetime() ;
  const ::Timestamp& responsetime() const;
  PROTOBUF_NODISCARD ::Timestamp* release_responsetime();
  ::Timestamp* mutable_responsetime();
  void set_allocated_responsetime(::Timestamp* value);
  void unsafe_arena_set_allocated_responsetime(::Timestamp* value);
  ::Timestamp* unsafe_arena_release_responsetime();

  private:
  const ::Timestamp& _internal_responsetime() const;
  ::Timestamp* _internal_mutable_responsetime();

  public:
  // uint32 providerId = 1;
  void clear_providerid() ;
  ::uint32_t providerid() const;
  void set_providerid(::uint32_t value);

  private:
  ::uint32_t _internal_providerid() const;
  void _internal_set_providerid(::uint32_t value);

  public:
  // .ExceptionalResult exceptionalResult = 10;
  bool has_exceptionalresult() const;
  private:
  bool _internal_has_exceptionalresult() const;

  public:
  void clear_exceptionalresult() ;
  const ::ExceptionalResult& exceptionalresult() const;
  PROTOBUF_NODISCARD ::ExceptionalResult* release_exceptionalresult();
  ::ExceptionalResult* mutable_exceptionalresult();
  void set_allocated_exceptionalresult(::ExceptionalResult* value);
  void unsafe_arena_set_allocated_exceptionalresult(::ExceptionalResult* value);
  ::ExceptionalResult* unsafe_arena_release_exceptionalresult();

  private:
  const ::ExceptionalResult& _internal_exceptionalresult() const;
  ::ExceptionalResult* _internal_mutable_exceptionalresult();

  public:
  // .dp.service.ingestion.IngestDataResponse.AckResult ackResult = 11;
  bool has_ackresult() const;
  private:
  bool _internal_has_ackresult() const;

  public:
  void clear_ackresult() ;
  const ::dp::service::ingestion::IngestDataResponse_AckResult& ackresult() const;
  PROTOBUF_NODISCARD ::dp::service::ingestion::IngestDataResponse_AckResult* release_ackresult();
  ::dp::service::ingestion::IngestDataResponse_AckResult* mutable_ackresult();
  void set_allocated_ackresult(::dp::service::ingestion::IngestDataResponse_AckResult* value);
  void unsafe_arena_set_allocated_ackresult(::dp::service::ingestion::IngestDataResponse_AckResult* value);
  ::dp::service::ingestion::IngestDataResponse_AckResult* unsafe_arena_release_ackresult();

  private:
  const ::dp::service::ingestion::IngestDataResponse_AckResult& _internal_ackresult() const;
  ::dp::service::ingestion::IngestDataResponse_AckResult* _internal_mutable_ackresult();

  public:
  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:dp.service.ingestion.IngestDataResponse)
 private:
  class _Internal;
  void set_has_exceptionalresult();
  void set_has_ackresult();
  inline bool has_result() const;
  inline void clear_has_result();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 3,
      63, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr clientrequestid_;
    ::Timestamp* responsetime_;
    ::uint32_t providerid_;
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::ExceptionalResult* exceptionalresult_;
      ::dp::service::ingestion::IngestDataResponse_AckResult* ackresult_;
    } result_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ingestion_2eproto;
};
// -------------------------------------------------------------------

class IngestDataRequest_IngestionDataFrame final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dp.service.ingestion.IngestDataRequest.IngestionDataFrame) */ {
 public:
  inline IngestDataRequest_IngestionDataFrame() : IngestDataRequest_IngestionDataFrame(nullptr) {}
  ~IngestDataRequest_IngestionDataFrame() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IngestDataRequest_IngestionDataFrame(
      ::google::protobuf::internal::ConstantInitialized);

  inline IngestDataRequest_IngestionDataFrame(const IngestDataRequest_IngestionDataFrame& from) : IngestDataRequest_IngestionDataFrame(nullptr, from) {}
  inline IngestDataRequest_IngestionDataFrame(IngestDataRequest_IngestionDataFrame&& from) noexcept
      : IngestDataRequest_IngestionDataFrame(nullptr, std::move(from)) {}
  inline IngestDataRequest_IngestionDataFrame& operator=(const IngestDataRequest_IngestionDataFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngestDataRequest_IngestionDataFrame& operator=(IngestDataRequest_IngestionDataFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngestDataRequest_IngestionDataFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const IngestDataRequest_IngestionDataFrame* internal_default_instance() {
    return reinterpret_cast<const IngestDataRequest_IngestionDataFrame*>(
        &_IngestDataRequest_IngestionDataFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(IngestDataRequest_IngestionDataFrame& a, IngestDataRequest_IngestionDataFrame& b) { a.Swap(&b); }
  inline void Swap(IngestDataRequest_IngestionDataFrame* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngestDataRequest_IngestionDataFrame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngestDataRequest_IngestionDataFrame* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<IngestDataRequest_IngestionDataFrame>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IngestDataRequest_IngestionDataFrame& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IngestDataRequest_IngestionDataFrame& from) { IngestDataRequest_IngestionDataFrame::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IngestDataRequest_IngestionDataFrame* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dp.service.ingestion.IngestDataRequest.IngestionDataFrame"; }

 protected:
  explicit IngestDataRequest_IngestionDataFrame(::google::protobuf::Arena* arena);
  IngestDataRequest_IngestionDataFrame(::google::protobuf::Arena* arena, const IngestDataRequest_IngestionDataFrame& from);
  IngestDataRequest_IngestionDataFrame(::google::protobuf::Arena* arena, IngestDataRequest_IngestionDataFrame&& from) noexcept
      : IngestDataRequest_IngestionDataFrame(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataColumnsFieldNumber = 2,
    kDataTimestampsFieldNumber = 1,
  };
  // repeated .DataColumn dataColumns = 2;
  int datacolumns_size() const;
  private:
  int _internal_datacolumns_size() const;

  public:
  void clear_datacolumns() ;
  ::DataColumn* mutable_datacolumns(int index);
  ::google::protobuf::RepeatedPtrField<::DataColumn>* mutable_datacolumns();

  private:
  const ::google::protobuf::RepeatedPtrField<::DataColumn>& _internal_datacolumns() const;
  ::google::protobuf::RepeatedPtrField<::DataColumn>* _internal_mutable_datacolumns();
  public:
  const ::DataColumn& datacolumns(int index) const;
  ::DataColumn* add_datacolumns();
  const ::google::protobuf::RepeatedPtrField<::DataColumn>& datacolumns() const;
  // .DataTimestamps dataTimestamps = 1;
  bool has_datatimestamps() const;
  void clear_datatimestamps() ;
  const ::DataTimestamps& datatimestamps() const;
  PROTOBUF_NODISCARD ::DataTimestamps* release_datatimestamps();
  ::DataTimestamps* mutable_datatimestamps();
  void set_allocated_datatimestamps(::DataTimestamps* value);
  void unsafe_arena_set_allocated_datatimestamps(::DataTimestamps* value);
  ::DataTimestamps* unsafe_arena_release_datatimestamps();

  private:
  const ::DataTimestamps& _internal_datatimestamps() const;
  ::DataTimestamps* _internal_mutable_datatimestamps();

  public:
  // @@protoc_insertion_point(class_scope:dp.service.ingestion.IngestDataRequest.IngestionDataFrame)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::DataColumn > datacolumns_;
    ::DataTimestamps* datatimestamps_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ingestion_2eproto;
};
// -------------------------------------------------------------------

class IngestDataRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:dp.service.ingestion.IngestDataRequest) */ {
 public:
  inline IngestDataRequest() : IngestDataRequest(nullptr) {}
  ~IngestDataRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IngestDataRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline IngestDataRequest(const IngestDataRequest& from) : IngestDataRequest(nullptr, from) {}
  inline IngestDataRequest(IngestDataRequest&& from) noexcept
      : IngestDataRequest(nullptr, std::move(from)) {}
  inline IngestDataRequest& operator=(const IngestDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngestDataRequest& operator=(IngestDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngestDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IngestDataRequest* internal_default_instance() {
    return reinterpret_cast<const IngestDataRequest*>(
        &_IngestDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(IngestDataRequest& a, IngestDataRequest& b) { a.Swap(&b); }
  inline void Swap(IngestDataRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngestDataRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngestDataRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<IngestDataRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IngestDataRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IngestDataRequest& from) { IngestDataRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IngestDataRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "dp.service.ingestion.IngestDataRequest"; }

 protected:
  explicit IngestDataRequest(::google::protobuf::Arena* arena);
  IngestDataRequest(::google::protobuf::Arena* arena, const IngestDataRequest& from);
  IngestDataRequest(::google::protobuf::Arena* arena, IngestDataRequest&& from) noexcept
      : IngestDataRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using IngestionDataFrame = IngestDataRequest_IngestionDataFrame;

  // accessors -------------------------------------------------------
  enum : int {
    kAttributesFieldNumber = 4,
    kClientRequestIdFieldNumber = 2,
    kRequestTimeFieldNumber = 3,
    kEventMetadataFieldNumber = 5,
    kIngestionDataFrameFieldNumber = 6,
    kProviderIdFieldNumber = 1,
  };
  // repeated .Attribute attributes = 4;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  ::Attribute* mutable_attributes(int index);
  ::google::protobuf::RepeatedPtrField<::Attribute>* mutable_attributes();

  private:
  const ::google::protobuf::RepeatedPtrField<::Attribute>& _internal_attributes() const;
  ::google::protobuf::RepeatedPtrField<::Attribute>* _internal_mutable_attributes();
  public:
  const ::Attribute& attributes(int index) const;
  ::Attribute* add_attributes();
  const ::google::protobuf::RepeatedPtrField<::Attribute>& attributes() const;
  // string clientRequestId = 2;
  void clear_clientrequestid() ;
  const std::string& clientrequestid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientrequestid(Arg_&& arg, Args_... args);
  std::string* mutable_clientrequestid();
  PROTOBUF_NODISCARD std::string* release_clientrequestid();
  void set_allocated_clientrequestid(std::string* value);

  private:
  const std::string& _internal_clientrequestid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientrequestid(
      const std::string& value);
  std::string* _internal_mutable_clientrequestid();

  public:
  // .Timestamp requestTime = 3;
  bool has_requesttime() const;
  void clear_requesttime() ;
  const ::Timestamp& requesttime() const;
  PROTOBUF_NODISCARD ::Timestamp* release_requesttime();
  ::Timestamp* mutable_requesttime();
  void set_allocated_requesttime(::Timestamp* value);
  void unsafe_arena_set_allocated_requesttime(::Timestamp* value);
  ::Timestamp* unsafe_arena_release_requesttime();

  private:
  const ::Timestamp& _internal_requesttime() const;
  ::Timestamp* _internal_mutable_requesttime();

  public:
  // .EventMetadata eventMetadata = 5;
  bool has_eventmetadata() const;
  void clear_eventmetadata() ;
  const ::EventMetadata& eventmetadata() const;
  PROTOBUF_NODISCARD ::EventMetadata* release_eventmetadata();
  ::EventMetadata* mutable_eventmetadata();
  void set_allocated_eventmetadata(::EventMetadata* value);
  void unsafe_arena_set_allocated_eventmetadata(::EventMetadata* value);
  ::EventMetadata* unsafe_arena_release_eventmetadata();

  private:
  const ::EventMetadata& _internal_eventmetadata() const;
  ::EventMetadata* _internal_mutable_eventmetadata();

  public:
  // .dp.service.ingestion.IngestDataRequest.IngestionDataFrame ingestionDataFrame = 6;
  bool has_ingestiondataframe() const;
  void clear_ingestiondataframe() ;
  const ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame& ingestiondataframe() const;
  PROTOBUF_NODISCARD ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* release_ingestiondataframe();
  ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* mutable_ingestiondataframe();
  void set_allocated_ingestiondataframe(::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* value);
  void unsafe_arena_set_allocated_ingestiondataframe(::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* value);
  ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* unsafe_arena_release_ingestiondataframe();

  private:
  const ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame& _internal_ingestiondataframe() const;
  ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* _internal_mutable_ingestiondataframe();

  public:
  // uint32 providerId = 1;
  void clear_providerid() ;
  ::uint32_t providerid() const;
  void set_providerid(::uint32_t value);

  private:
  ::uint32_t _internal_providerid() const;
  void _internal_set_providerid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dp.service.ingestion.IngestDataRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 4,
      62, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::Attribute > attributes_;
    ::google::protobuf::internal::ArenaStringPtr clientrequestid_;
    ::Timestamp* requesttime_;
    ::EventMetadata* eventmetadata_;
    ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* ingestiondataframe_;
    ::uint32_t providerid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ingestion_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RegisterProviderRequest

// string providerName = 1;
inline void RegisterProviderRequest::clear_providername() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.providername_.ClearToEmpty();
}
inline const std::string& RegisterProviderRequest::providername() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.RegisterProviderRequest.providerName)
  return _internal_providername();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterProviderRequest::set_providername(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.providername_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dp.service.ingestion.RegisterProviderRequest.providerName)
}
inline std::string* RegisterProviderRequest::mutable_providername() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_providername();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.RegisterProviderRequest.providerName)
  return _s;
}
inline const std::string& RegisterProviderRequest::_internal_providername() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.providername_.Get();
}
inline void RegisterProviderRequest::_internal_set_providername(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.providername_.Set(value, GetArena());
}
inline std::string* RegisterProviderRequest::_internal_mutable_providername() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.providername_.Mutable( GetArena());
}
inline std::string* RegisterProviderRequest::release_providername() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dp.service.ingestion.RegisterProviderRequest.providerName)
  return _impl_.providername_.Release();
}
inline void RegisterProviderRequest::set_allocated_providername(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.providername_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.providername_.IsDefault()) {
          _impl_.providername_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.RegisterProviderRequest.providerName)
}

// repeated .Attribute attributes = 2;
inline int RegisterProviderRequest::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int RegisterProviderRequest::attributes_size() const {
  return _internal_attributes_size();
}
inline ::Attribute* RegisterProviderRequest::mutable_attributes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.RegisterProviderRequest.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Attribute>* RegisterProviderRequest::mutable_attributes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dp.service.ingestion.RegisterProviderRequest.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::Attribute& RegisterProviderRequest::attributes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.RegisterProviderRequest.attributes)
  return _internal_attributes().Get(index);
}
inline ::Attribute* RegisterProviderRequest::add_attributes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Attribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:dp.service.ingestion.RegisterProviderRequest.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Attribute>& RegisterProviderRequest::attributes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dp.service.ingestion.RegisterProviderRequest.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::Attribute>&
RegisterProviderRequest::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::Attribute>*
RegisterProviderRequest::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// .Timestamp requestTime = 3;
inline bool RegisterProviderRequest::has_requesttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.requesttime_ != nullptr);
  return value;
}
inline const ::Timestamp& RegisterProviderRequest::_internal_requesttime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Timestamp* p = _impl_.requesttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::Timestamp&>(::_Timestamp_default_instance_);
}
inline const ::Timestamp& RegisterProviderRequest::requesttime() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.RegisterProviderRequest.requestTime)
  return _internal_requesttime();
}
inline void RegisterProviderRequest::unsafe_arena_set_allocated_requesttime(::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.requesttime_);
  }
  _impl_.requesttime_ = reinterpret_cast<::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.RegisterProviderRequest.requestTime)
}
inline ::Timestamp* RegisterProviderRequest::release_requesttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Timestamp* released = _impl_.requesttime_;
  _impl_.requesttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Timestamp* RegisterProviderRequest::unsafe_arena_release_requesttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dp.service.ingestion.RegisterProviderRequest.requestTime)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Timestamp* temp = _impl_.requesttime_;
  _impl_.requesttime_ = nullptr;
  return temp;
}
inline ::Timestamp* RegisterProviderRequest::_internal_mutable_requesttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.requesttime_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Timestamp>(GetArena());
    _impl_.requesttime_ = reinterpret_cast<::Timestamp*>(p);
  }
  return _impl_.requesttime_;
}
inline ::Timestamp* RegisterProviderRequest::mutable_requesttime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Timestamp* _msg = _internal_mutable_requesttime();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.RegisterProviderRequest.requestTime)
  return _msg;
}
inline void RegisterProviderRequest::set_allocated_requesttime(::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.requesttime_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.requesttime_ = reinterpret_cast<::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.RegisterProviderRequest.requestTime)
}

// -------------------------------------------------------------------

// RegisterProviderResponse_RegistrationResult

// uint32 providerId = 1;
inline void RegisterProviderResponse_RegistrationResult::clear_providerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.providerid_ = 0u;
}
inline ::uint32_t RegisterProviderResponse_RegistrationResult::providerid() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.RegisterProviderResponse.RegistrationResult.providerId)
  return _internal_providerid();
}
inline void RegisterProviderResponse_RegistrationResult::set_providerid(::uint32_t value) {
  _internal_set_providerid(value);
  // @@protoc_insertion_point(field_set:dp.service.ingestion.RegisterProviderResponse.RegistrationResult.providerId)
}
inline ::uint32_t RegisterProviderResponse_RegistrationResult::_internal_providerid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.providerid_;
}
inline void RegisterProviderResponse_RegistrationResult::_internal_set_providerid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.providerid_ = value;
}

// -------------------------------------------------------------------

// RegisterProviderResponse

// .Timestamp responseTime = 1;
inline bool RegisterProviderResponse::has_responsetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.responsetime_ != nullptr);
  return value;
}
inline const ::Timestamp& RegisterProviderResponse::_internal_responsetime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Timestamp* p = _impl_.responsetime_;
  return p != nullptr ? *p : reinterpret_cast<const ::Timestamp&>(::_Timestamp_default_instance_);
}
inline const ::Timestamp& RegisterProviderResponse::responsetime() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.RegisterProviderResponse.responseTime)
  return _internal_responsetime();
}
inline void RegisterProviderResponse::unsafe_arena_set_allocated_responsetime(::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.responsetime_);
  }
  _impl_.responsetime_ = reinterpret_cast<::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.RegisterProviderResponse.responseTime)
}
inline ::Timestamp* RegisterProviderResponse::release_responsetime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Timestamp* released = _impl_.responsetime_;
  _impl_.responsetime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Timestamp* RegisterProviderResponse::unsafe_arena_release_responsetime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dp.service.ingestion.RegisterProviderResponse.responseTime)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Timestamp* temp = _impl_.responsetime_;
  _impl_.responsetime_ = nullptr;
  return temp;
}
inline ::Timestamp* RegisterProviderResponse::_internal_mutable_responsetime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.responsetime_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Timestamp>(GetArena());
    _impl_.responsetime_ = reinterpret_cast<::Timestamp*>(p);
  }
  return _impl_.responsetime_;
}
inline ::Timestamp* RegisterProviderResponse::mutable_responsetime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Timestamp* _msg = _internal_mutable_responsetime();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.RegisterProviderResponse.responseTime)
  return _msg;
}
inline void RegisterProviderResponse::set_allocated_responsetime(::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.responsetime_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.responsetime_ = reinterpret_cast<::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.RegisterProviderResponse.responseTime)
}

// .ExceptionalResult exceptionalResult = 10;
inline bool RegisterProviderResponse::has_exceptionalresult() const {
  return result_case() == kExceptionalResult;
}
inline bool RegisterProviderResponse::_internal_has_exceptionalresult() const {
  return result_case() == kExceptionalResult;
}
inline void RegisterProviderResponse::set_has_exceptionalresult() {
  _impl_._oneof_case_[0] = kExceptionalResult;
}
inline ::ExceptionalResult* RegisterProviderResponse::release_exceptionalresult() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.RegisterProviderResponse.exceptionalResult)
  if (result_case() == kExceptionalResult) {
    clear_has_result();
    auto* temp = _impl_.result_.exceptionalresult_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.exceptionalresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ExceptionalResult& RegisterProviderResponse::_internal_exceptionalresult() const {
  return result_case() == kExceptionalResult ? *_impl_.result_.exceptionalresult_ : reinterpret_cast<::ExceptionalResult&>(::_ExceptionalResult_default_instance_);
}
inline const ::ExceptionalResult& RegisterProviderResponse::exceptionalresult() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.RegisterProviderResponse.exceptionalResult)
  return _internal_exceptionalresult();
}
inline ::ExceptionalResult* RegisterProviderResponse::unsafe_arena_release_exceptionalresult() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dp.service.ingestion.RegisterProviderResponse.exceptionalResult)
  if (result_case() == kExceptionalResult) {
    clear_has_result();
    auto* temp = _impl_.result_.exceptionalresult_;
    _impl_.result_.exceptionalresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegisterProviderResponse::unsafe_arena_set_allocated_exceptionalresult(::ExceptionalResult* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_result();
  if (value) {
    set_has_exceptionalresult();
    _impl_.result_.exceptionalresult_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.RegisterProviderResponse.exceptionalResult)
}
inline ::ExceptionalResult* RegisterProviderResponse::_internal_mutable_exceptionalresult() {
  if (result_case() != kExceptionalResult) {
    clear_result();
    set_has_exceptionalresult();
    _impl_.result_.exceptionalresult_ =
        ::google::protobuf::Message::DefaultConstruct<::ExceptionalResult>(GetArena());
  }
  return _impl_.result_.exceptionalresult_;
}
inline ::ExceptionalResult* RegisterProviderResponse::mutable_exceptionalresult() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ExceptionalResult* _msg = _internal_mutable_exceptionalresult();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.RegisterProviderResponse.exceptionalResult)
  return _msg;
}

// .dp.service.ingestion.RegisterProviderResponse.RegistrationResult registrationResult = 11;
inline bool RegisterProviderResponse::has_registrationresult() const {
  return result_case() == kRegistrationResult;
}
inline bool RegisterProviderResponse::_internal_has_registrationresult() const {
  return result_case() == kRegistrationResult;
}
inline void RegisterProviderResponse::set_has_registrationresult() {
  _impl_._oneof_case_[0] = kRegistrationResult;
}
inline void RegisterProviderResponse::clear_registrationresult() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (result_case() == kRegistrationResult) {
    if (GetArena() == nullptr) {
      delete _impl_.result_.registrationresult_;
    }
    clear_has_result();
  }
}
inline ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* RegisterProviderResponse::release_registrationresult() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.RegisterProviderResponse.registrationResult)
  if (result_case() == kRegistrationResult) {
    clear_has_result();
    auto* temp = _impl_.result_.registrationresult_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.registrationresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult& RegisterProviderResponse::_internal_registrationresult() const {
  return result_case() == kRegistrationResult ? *_impl_.result_.registrationresult_ : reinterpret_cast<::dp::service::ingestion::RegisterProviderResponse_RegistrationResult&>(::dp::service::ingestion::_RegisterProviderResponse_RegistrationResult_default_instance_);
}
inline const ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult& RegisterProviderResponse::registrationresult() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.RegisterProviderResponse.registrationResult)
  return _internal_registrationresult();
}
inline ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* RegisterProviderResponse::unsafe_arena_release_registrationresult() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dp.service.ingestion.RegisterProviderResponse.registrationResult)
  if (result_case() == kRegistrationResult) {
    clear_has_result();
    auto* temp = _impl_.result_.registrationresult_;
    _impl_.result_.registrationresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegisterProviderResponse::unsafe_arena_set_allocated_registrationresult(::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_result();
  if (value) {
    set_has_registrationresult();
    _impl_.result_.registrationresult_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.RegisterProviderResponse.registrationResult)
}
inline ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* RegisterProviderResponse::_internal_mutable_registrationresult() {
  if (result_case() != kRegistrationResult) {
    clear_result();
    set_has_registrationresult();
    _impl_.result_.registrationresult_ =
        ::google::protobuf::Message::DefaultConstruct<::dp::service::ingestion::RegisterProviderResponse_RegistrationResult>(GetArena());
  }
  return _impl_.result_.registrationresult_;
}
inline ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* RegisterProviderResponse::mutable_registrationresult() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dp::service::ingestion::RegisterProviderResponse_RegistrationResult* _msg = _internal_mutable_registrationresult();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.RegisterProviderResponse.registrationResult)
  return _msg;
}

inline bool RegisterProviderResponse::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void RegisterProviderResponse::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline RegisterProviderResponse::ResultCase RegisterProviderResponse::result_case() const {
  return RegisterProviderResponse::ResultCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// IngestDataRequest_IngestionDataFrame

// .DataTimestamps dataTimestamps = 1;
inline bool IngestDataRequest_IngestionDataFrame::has_datatimestamps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.datatimestamps_ != nullptr);
  return value;
}
inline const ::DataTimestamps& IngestDataRequest_IngestionDataFrame::_internal_datatimestamps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::DataTimestamps* p = _impl_.datatimestamps_;
  return p != nullptr ? *p : reinterpret_cast<const ::DataTimestamps&>(::_DataTimestamps_default_instance_);
}
inline const ::DataTimestamps& IngestDataRequest_IngestionDataFrame::datatimestamps() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataTimestamps)
  return _internal_datatimestamps();
}
inline void IngestDataRequest_IngestionDataFrame::unsafe_arena_set_allocated_datatimestamps(::DataTimestamps* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.datatimestamps_);
  }
  _impl_.datatimestamps_ = reinterpret_cast<::DataTimestamps*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataTimestamps)
}
inline ::DataTimestamps* IngestDataRequest_IngestionDataFrame::release_datatimestamps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DataTimestamps* released = _impl_.datatimestamps_;
  _impl_.datatimestamps_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::DataTimestamps* IngestDataRequest_IngestionDataFrame::unsafe_arena_release_datatimestamps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataTimestamps)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::DataTimestamps* temp = _impl_.datatimestamps_;
  _impl_.datatimestamps_ = nullptr;
  return temp;
}
inline ::DataTimestamps* IngestDataRequest_IngestionDataFrame::_internal_mutable_datatimestamps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.datatimestamps_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::DataTimestamps>(GetArena());
    _impl_.datatimestamps_ = reinterpret_cast<::DataTimestamps*>(p);
  }
  return _impl_.datatimestamps_;
}
inline ::DataTimestamps* IngestDataRequest_IngestionDataFrame::mutable_datatimestamps() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::DataTimestamps* _msg = _internal_mutable_datatimestamps();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataTimestamps)
  return _msg;
}
inline void IngestDataRequest_IngestionDataFrame::set_allocated_datatimestamps(::DataTimestamps* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.datatimestamps_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.datatimestamps_ = reinterpret_cast<::DataTimestamps*>(value);
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataTimestamps)
}

// repeated .DataColumn dataColumns = 2;
inline int IngestDataRequest_IngestionDataFrame::_internal_datacolumns_size() const {
  return _internal_datacolumns().size();
}
inline int IngestDataRequest_IngestionDataFrame::datacolumns_size() const {
  return _internal_datacolumns_size();
}
inline ::DataColumn* IngestDataRequest_IngestionDataFrame::mutable_datacolumns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataColumns)
  return _internal_mutable_datacolumns()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DataColumn>* IngestDataRequest_IngestionDataFrame::mutable_datacolumns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataColumns)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_datacolumns();
}
inline const ::DataColumn& IngestDataRequest_IngestionDataFrame::datacolumns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataColumns)
  return _internal_datacolumns().Get(index);
}
inline ::DataColumn* IngestDataRequest_IngestionDataFrame::add_datacolumns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DataColumn* _add = _internal_mutable_datacolumns()->Add();
  // @@protoc_insertion_point(field_add:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataColumns)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DataColumn>& IngestDataRequest_IngestionDataFrame::datacolumns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dp.service.ingestion.IngestDataRequest.IngestionDataFrame.dataColumns)
  return _internal_datacolumns();
}
inline const ::google::protobuf::RepeatedPtrField<::DataColumn>&
IngestDataRequest_IngestionDataFrame::_internal_datacolumns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.datacolumns_;
}
inline ::google::protobuf::RepeatedPtrField<::DataColumn>*
IngestDataRequest_IngestionDataFrame::_internal_mutable_datacolumns() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.datacolumns_;
}

// -------------------------------------------------------------------

// IngestDataRequest

// uint32 providerId = 1;
inline void IngestDataRequest::clear_providerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.providerid_ = 0u;
}
inline ::uint32_t IngestDataRequest::providerid() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.providerId)
  return _internal_providerid();
}
inline void IngestDataRequest::set_providerid(::uint32_t value) {
  _internal_set_providerid(value);
  // @@protoc_insertion_point(field_set:dp.service.ingestion.IngestDataRequest.providerId)
}
inline ::uint32_t IngestDataRequest::_internal_providerid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.providerid_;
}
inline void IngestDataRequest::_internal_set_providerid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.providerid_ = value;
}

// string clientRequestId = 2;
inline void IngestDataRequest::clear_clientrequestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientrequestid_.ClearToEmpty();
}
inline const std::string& IngestDataRequest::clientrequestid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.clientRequestId)
  return _internal_clientrequestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IngestDataRequest::set_clientrequestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientrequestid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dp.service.ingestion.IngestDataRequest.clientRequestId)
}
inline std::string* IngestDataRequest::mutable_clientrequestid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_clientrequestid();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataRequest.clientRequestId)
  return _s;
}
inline const std::string& IngestDataRequest::_internal_clientrequestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clientrequestid_.Get();
}
inline void IngestDataRequest::_internal_set_clientrequestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientrequestid_.Set(value, GetArena());
}
inline std::string* IngestDataRequest::_internal_mutable_clientrequestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.clientrequestid_.Mutable( GetArena());
}
inline std::string* IngestDataRequest::release_clientrequestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataRequest.clientRequestId)
  return _impl_.clientrequestid_.Release();
}
inline void IngestDataRequest::set_allocated_clientrequestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientrequestid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientrequestid_.IsDefault()) {
          _impl_.clientrequestid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.IngestDataRequest.clientRequestId)
}

// .Timestamp requestTime = 3;
inline bool IngestDataRequest::has_requesttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.requesttime_ != nullptr);
  return value;
}
inline const ::Timestamp& IngestDataRequest::_internal_requesttime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Timestamp* p = _impl_.requesttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::Timestamp&>(::_Timestamp_default_instance_);
}
inline const ::Timestamp& IngestDataRequest::requesttime() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.requestTime)
  return _internal_requesttime();
}
inline void IngestDataRequest::unsafe_arena_set_allocated_requesttime(::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.requesttime_);
  }
  _impl_.requesttime_ = reinterpret_cast<::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.IngestDataRequest.requestTime)
}
inline ::Timestamp* IngestDataRequest::release_requesttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Timestamp* released = _impl_.requesttime_;
  _impl_.requesttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Timestamp* IngestDataRequest::unsafe_arena_release_requesttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataRequest.requestTime)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Timestamp* temp = _impl_.requesttime_;
  _impl_.requesttime_ = nullptr;
  return temp;
}
inline ::Timestamp* IngestDataRequest::_internal_mutable_requesttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.requesttime_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Timestamp>(GetArena());
    _impl_.requesttime_ = reinterpret_cast<::Timestamp*>(p);
  }
  return _impl_.requesttime_;
}
inline ::Timestamp* IngestDataRequest::mutable_requesttime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Timestamp* _msg = _internal_mutable_requesttime();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataRequest.requestTime)
  return _msg;
}
inline void IngestDataRequest::set_allocated_requesttime(::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.requesttime_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.requesttime_ = reinterpret_cast<::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.IngestDataRequest.requestTime)
}

// repeated .Attribute attributes = 4;
inline int IngestDataRequest::_internal_attributes_size() const {
  return _internal_attributes().size();
}
inline int IngestDataRequest::attributes_size() const {
  return _internal_attributes_size();
}
inline ::Attribute* IngestDataRequest::mutable_attributes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataRequest.attributes)
  return _internal_mutable_attributes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Attribute>* IngestDataRequest::mutable_attributes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:dp.service.ingestion.IngestDataRequest.attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attributes();
}
inline const ::Attribute& IngestDataRequest::attributes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.attributes)
  return _internal_attributes().Get(index);
}
inline ::Attribute* IngestDataRequest::add_attributes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Attribute* _add = _internal_mutable_attributes()->Add();
  // @@protoc_insertion_point(field_add:dp.service.ingestion.IngestDataRequest.attributes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Attribute>& IngestDataRequest::attributes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:dp.service.ingestion.IngestDataRequest.attributes)
  return _internal_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<::Attribute>&
IngestDataRequest::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attributes_;
}
inline ::google::protobuf::RepeatedPtrField<::Attribute>*
IngestDataRequest::_internal_mutable_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attributes_;
}

// .EventMetadata eventMetadata = 5;
inline bool IngestDataRequest::has_eventmetadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.eventmetadata_ != nullptr);
  return value;
}
inline const ::EventMetadata& IngestDataRequest::_internal_eventmetadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::EventMetadata* p = _impl_.eventmetadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::EventMetadata&>(::_EventMetadata_default_instance_);
}
inline const ::EventMetadata& IngestDataRequest::eventmetadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.eventMetadata)
  return _internal_eventmetadata();
}
inline void IngestDataRequest::unsafe_arena_set_allocated_eventmetadata(::EventMetadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventmetadata_);
  }
  _impl_.eventmetadata_ = reinterpret_cast<::EventMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.IngestDataRequest.eventMetadata)
}
inline ::EventMetadata* IngestDataRequest::release_eventmetadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::EventMetadata* released = _impl_.eventmetadata_;
  _impl_.eventmetadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::EventMetadata* IngestDataRequest::unsafe_arena_release_eventmetadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataRequest.eventMetadata)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::EventMetadata* temp = _impl_.eventmetadata_;
  _impl_.eventmetadata_ = nullptr;
  return temp;
}
inline ::EventMetadata* IngestDataRequest::_internal_mutable_eventmetadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.eventmetadata_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::EventMetadata>(GetArena());
    _impl_.eventmetadata_ = reinterpret_cast<::EventMetadata*>(p);
  }
  return _impl_.eventmetadata_;
}
inline ::EventMetadata* IngestDataRequest::mutable_eventmetadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::EventMetadata* _msg = _internal_mutable_eventmetadata();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataRequest.eventMetadata)
  return _msg;
}
inline void IngestDataRequest::set_allocated_eventmetadata(::EventMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eventmetadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.eventmetadata_ = reinterpret_cast<::EventMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.IngestDataRequest.eventMetadata)
}

// .dp.service.ingestion.IngestDataRequest.IngestionDataFrame ingestionDataFrame = 6;
inline bool IngestDataRequest::has_ingestiondataframe() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ingestiondataframe_ != nullptr);
  return value;
}
inline void IngestDataRequest::clear_ingestiondataframe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ingestiondataframe_ != nullptr) _impl_.ingestiondataframe_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame& IngestDataRequest::_internal_ingestiondataframe() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* p = _impl_.ingestiondataframe_;
  return p != nullptr ? *p : reinterpret_cast<const ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame&>(::dp::service::ingestion::_IngestDataRequest_IngestionDataFrame_default_instance_);
}
inline const ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame& IngestDataRequest::ingestiondataframe() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataRequest.ingestionDataFrame)
  return _internal_ingestiondataframe();
}
inline void IngestDataRequest::unsafe_arena_set_allocated_ingestiondataframe(::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ingestiondataframe_);
  }
  _impl_.ingestiondataframe_ = reinterpret_cast<::dp::service::ingestion::IngestDataRequest_IngestionDataFrame*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.IngestDataRequest.ingestionDataFrame)
}
inline ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* IngestDataRequest::release_ingestiondataframe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* released = _impl_.ingestiondataframe_;
  _impl_.ingestiondataframe_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* IngestDataRequest::unsafe_arena_release_ingestiondataframe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataRequest.ingestionDataFrame)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* temp = _impl_.ingestiondataframe_;
  _impl_.ingestiondataframe_ = nullptr;
  return temp;
}
inline ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* IngestDataRequest::_internal_mutable_ingestiondataframe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ingestiondataframe_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::dp::service::ingestion::IngestDataRequest_IngestionDataFrame>(GetArena());
    _impl_.ingestiondataframe_ = reinterpret_cast<::dp::service::ingestion::IngestDataRequest_IngestionDataFrame*>(p);
  }
  return _impl_.ingestiondataframe_;
}
inline ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* IngestDataRequest::mutable_ingestiondataframe() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* _msg = _internal_mutable_ingestiondataframe();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataRequest.ingestionDataFrame)
  return _msg;
}
inline void IngestDataRequest::set_allocated_ingestiondataframe(::dp::service::ingestion::IngestDataRequest_IngestionDataFrame* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.ingestiondataframe_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.ingestiondataframe_ = reinterpret_cast<::dp::service::ingestion::IngestDataRequest_IngestionDataFrame*>(value);
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.IngestDataRequest.ingestionDataFrame)
}

// -------------------------------------------------------------------

// IngestDataResponse_AckResult

// uint32 numRows = 1;
inline void IngestDataResponse_AckResult::clear_numrows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.numrows_ = 0u;
}
inline ::uint32_t IngestDataResponse_AckResult::numrows() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataResponse.AckResult.numRows)
  return _internal_numrows();
}
inline void IngestDataResponse_AckResult::set_numrows(::uint32_t value) {
  _internal_set_numrows(value);
  // @@protoc_insertion_point(field_set:dp.service.ingestion.IngestDataResponse.AckResult.numRows)
}
inline ::uint32_t IngestDataResponse_AckResult::_internal_numrows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.numrows_;
}
inline void IngestDataResponse_AckResult::_internal_set_numrows(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.numrows_ = value;
}

// uint32 numColumns = 2;
inline void IngestDataResponse_AckResult::clear_numcolumns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.numcolumns_ = 0u;
}
inline ::uint32_t IngestDataResponse_AckResult::numcolumns() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataResponse.AckResult.numColumns)
  return _internal_numcolumns();
}
inline void IngestDataResponse_AckResult::set_numcolumns(::uint32_t value) {
  _internal_set_numcolumns(value);
  // @@protoc_insertion_point(field_set:dp.service.ingestion.IngestDataResponse.AckResult.numColumns)
}
inline ::uint32_t IngestDataResponse_AckResult::_internal_numcolumns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.numcolumns_;
}
inline void IngestDataResponse_AckResult::_internal_set_numcolumns(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.numcolumns_ = value;
}

// -------------------------------------------------------------------

// IngestDataResponse

// uint32 providerId = 1;
inline void IngestDataResponse::clear_providerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.providerid_ = 0u;
}
inline ::uint32_t IngestDataResponse::providerid() const {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataResponse.providerId)
  return _internal_providerid();
}
inline void IngestDataResponse::set_providerid(::uint32_t value) {
  _internal_set_providerid(value);
  // @@protoc_insertion_point(field_set:dp.service.ingestion.IngestDataResponse.providerId)
}
inline ::uint32_t IngestDataResponse::_internal_providerid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.providerid_;
}
inline void IngestDataResponse::_internal_set_providerid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.providerid_ = value;
}

// string clientRequestId = 2;
inline void IngestDataResponse::clear_clientrequestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientrequestid_.ClearToEmpty();
}
inline const std::string& IngestDataResponse::clientrequestid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataResponse.clientRequestId)
  return _internal_clientrequestid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IngestDataResponse::set_clientrequestid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientrequestid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:dp.service.ingestion.IngestDataResponse.clientRequestId)
}
inline std::string* IngestDataResponse::mutable_clientrequestid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_clientrequestid();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataResponse.clientRequestId)
  return _s;
}
inline const std::string& IngestDataResponse::_internal_clientrequestid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clientrequestid_.Get();
}
inline void IngestDataResponse::_internal_set_clientrequestid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientrequestid_.Set(value, GetArena());
}
inline std::string* IngestDataResponse::_internal_mutable_clientrequestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.clientrequestid_.Mutable( GetArena());
}
inline std::string* IngestDataResponse::release_clientrequestid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataResponse.clientRequestId)
  return _impl_.clientrequestid_.Release();
}
inline void IngestDataResponse::set_allocated_clientrequestid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientrequestid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientrequestid_.IsDefault()) {
          _impl_.clientrequestid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.IngestDataResponse.clientRequestId)
}

// .Timestamp responseTime = 3;
inline bool IngestDataResponse::has_responsetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.responsetime_ != nullptr);
  return value;
}
inline const ::Timestamp& IngestDataResponse::_internal_responsetime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Timestamp* p = _impl_.responsetime_;
  return p != nullptr ? *p : reinterpret_cast<const ::Timestamp&>(::_Timestamp_default_instance_);
}
inline const ::Timestamp& IngestDataResponse::responsetime() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataResponse.responseTime)
  return _internal_responsetime();
}
inline void IngestDataResponse::unsafe_arena_set_allocated_responsetime(::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.responsetime_);
  }
  _impl_.responsetime_ = reinterpret_cast<::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.IngestDataResponse.responseTime)
}
inline ::Timestamp* IngestDataResponse::release_responsetime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Timestamp* released = _impl_.responsetime_;
  _impl_.responsetime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Timestamp* IngestDataResponse::unsafe_arena_release_responsetime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataResponse.responseTime)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Timestamp* temp = _impl_.responsetime_;
  _impl_.responsetime_ = nullptr;
  return temp;
}
inline ::Timestamp* IngestDataResponse::_internal_mutable_responsetime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.responsetime_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::Timestamp>(GetArena());
    _impl_.responsetime_ = reinterpret_cast<::Timestamp*>(p);
  }
  return _impl_.responsetime_;
}
inline ::Timestamp* IngestDataResponse::mutable_responsetime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::Timestamp* _msg = _internal_mutable_responsetime();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataResponse.responseTime)
  return _msg;
}
inline void IngestDataResponse::set_allocated_responsetime(::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.responsetime_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.responsetime_ = reinterpret_cast<::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:dp.service.ingestion.IngestDataResponse.responseTime)
}

// .ExceptionalResult exceptionalResult = 10;
inline bool IngestDataResponse::has_exceptionalresult() const {
  return result_case() == kExceptionalResult;
}
inline bool IngestDataResponse::_internal_has_exceptionalresult() const {
  return result_case() == kExceptionalResult;
}
inline void IngestDataResponse::set_has_exceptionalresult() {
  _impl_._oneof_case_[0] = kExceptionalResult;
}
inline ::ExceptionalResult* IngestDataResponse::release_exceptionalresult() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataResponse.exceptionalResult)
  if (result_case() == kExceptionalResult) {
    clear_has_result();
    auto* temp = _impl_.result_.exceptionalresult_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.exceptionalresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ExceptionalResult& IngestDataResponse::_internal_exceptionalresult() const {
  return result_case() == kExceptionalResult ? *_impl_.result_.exceptionalresult_ : reinterpret_cast<::ExceptionalResult&>(::_ExceptionalResult_default_instance_);
}
inline const ::ExceptionalResult& IngestDataResponse::exceptionalresult() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataResponse.exceptionalResult)
  return _internal_exceptionalresult();
}
inline ::ExceptionalResult* IngestDataResponse::unsafe_arena_release_exceptionalresult() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dp.service.ingestion.IngestDataResponse.exceptionalResult)
  if (result_case() == kExceptionalResult) {
    clear_has_result();
    auto* temp = _impl_.result_.exceptionalresult_;
    _impl_.result_.exceptionalresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IngestDataResponse::unsafe_arena_set_allocated_exceptionalresult(::ExceptionalResult* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_result();
  if (value) {
    set_has_exceptionalresult();
    _impl_.result_.exceptionalresult_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.IngestDataResponse.exceptionalResult)
}
inline ::ExceptionalResult* IngestDataResponse::_internal_mutable_exceptionalresult() {
  if (result_case() != kExceptionalResult) {
    clear_result();
    set_has_exceptionalresult();
    _impl_.result_.exceptionalresult_ =
        ::google::protobuf::Message::DefaultConstruct<::ExceptionalResult>(GetArena());
  }
  return _impl_.result_.exceptionalresult_;
}
inline ::ExceptionalResult* IngestDataResponse::mutable_exceptionalresult() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ExceptionalResult* _msg = _internal_mutable_exceptionalresult();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataResponse.exceptionalResult)
  return _msg;
}

// .dp.service.ingestion.IngestDataResponse.AckResult ackResult = 11;
inline bool IngestDataResponse::has_ackresult() const {
  return result_case() == kAckResult;
}
inline bool IngestDataResponse::_internal_has_ackresult() const {
  return result_case() == kAckResult;
}
inline void IngestDataResponse::set_has_ackresult() {
  _impl_._oneof_case_[0] = kAckResult;
}
inline void IngestDataResponse::clear_ackresult() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (result_case() == kAckResult) {
    if (GetArena() == nullptr) {
      delete _impl_.result_.ackresult_;
    }
    clear_has_result();
  }
}
inline ::dp::service::ingestion::IngestDataResponse_AckResult* IngestDataResponse::release_ackresult() {
  // @@protoc_insertion_point(field_release:dp.service.ingestion.IngestDataResponse.ackResult)
  if (result_case() == kAckResult) {
    clear_has_result();
    auto* temp = _impl_.result_.ackresult_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.ackresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dp::service::ingestion::IngestDataResponse_AckResult& IngestDataResponse::_internal_ackresult() const {
  return result_case() == kAckResult ? *_impl_.result_.ackresult_ : reinterpret_cast<::dp::service::ingestion::IngestDataResponse_AckResult&>(::dp::service::ingestion::_IngestDataResponse_AckResult_default_instance_);
}
inline const ::dp::service::ingestion::IngestDataResponse_AckResult& IngestDataResponse::ackresult() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dp.service.ingestion.IngestDataResponse.ackResult)
  return _internal_ackresult();
}
inline ::dp::service::ingestion::IngestDataResponse_AckResult* IngestDataResponse::unsafe_arena_release_ackresult() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dp.service.ingestion.IngestDataResponse.ackResult)
  if (result_case() == kAckResult) {
    clear_has_result();
    auto* temp = _impl_.result_.ackresult_;
    _impl_.result_.ackresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IngestDataResponse::unsafe_arena_set_allocated_ackresult(::dp::service::ingestion::IngestDataResponse_AckResult* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_result();
  if (value) {
    set_has_ackresult();
    _impl_.result_.ackresult_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dp.service.ingestion.IngestDataResponse.ackResult)
}
inline ::dp::service::ingestion::IngestDataResponse_AckResult* IngestDataResponse::_internal_mutable_ackresult() {
  if (result_case() != kAckResult) {
    clear_result();
    set_has_ackresult();
    _impl_.result_.ackresult_ =
        ::google::protobuf::Message::DefaultConstruct<::dp::service::ingestion::IngestDataResponse_AckResult>(GetArena());
  }
  return _impl_.result_.ackresult_;
}
inline ::dp::service::ingestion::IngestDataResponse_AckResult* IngestDataResponse::mutable_ackresult() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dp::service::ingestion::IngestDataResponse_AckResult* _msg = _internal_mutable_ackresult();
  // @@protoc_insertion_point(field_mutable:dp.service.ingestion.IngestDataResponse.ackResult)
  return _msg;
}

inline bool IngestDataResponse::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void IngestDataResponse::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline IngestDataResponse::ResultCase IngestDataResponse::result_case() const {
  return IngestDataResponse::ResultCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace ingestion
}  // namespace service
}  // namespace dp


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ingestion_2eproto_2epb_2eh
